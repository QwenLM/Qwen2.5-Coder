{"task_id": "HumanEval_23_strlen", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n\n    return string.length();", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();\n}\n\n// Return the character at the given index\n// >>> char_at((\"abc\"), 1)\n// ('b')\n// >>> char_at((\"abc\"), 0)\n// ('a')\n// >>> char_at((\"abc\"), 2)\n// ('c')\nchar char_at(std::string string, long index) {\n    return string[index];\n}\n\n// Return the first index of the given character\n// >>> index_of((\"abc\"), ('a'))\n// (0)\n// >>> index_of((\"abc\"), ('b'))\n// (1)\n// >>> index_of((\"abc\"), ('c'))\n// (2)\nlong index_of(std::string string, char character) {\n    return string.find(character);\n}\n\n// Return the substring from start index to end index\n// >>> substring((\"abc\"), 0, 1)\n// (\"a\")\n// >>> substring((\"abc\"), 1, 2)\n// (\"b\")\n// >>> substring((\"abc\"), 0, 2)\n// (\"ab\")\nstd::string substring(std::string string, long start, long end) {\n    return string.substr(start, end - start);\n}\n\n// Return the substring from start index to the end of the string\n// >>> substring((\"abc\"), 1)\n// (\"bc\")\n// >>> substring((\"abc\"), 0)\n// (\"abc\")\nstd::string substring(std::string string, long start) {\n    return string.substr(start);\n}\n\n// Return the string with the character at the given index replaced\n// >>> replace_char((\"abc\"), 1, ('d'))\n// (\"adc\")\n// >>> replace_char((\"abc\"), 0, ('d'))\n// (\"dbc\")\n// >>> replace_char((\"abc\"), 2, ('d'))\n// (\"abd\")\nstd::string replace_char(std::string string, long index, char character) {\n    string[index] = character;\n    return string;\n}\n\n// Return the string with the character at the given index removed\n// >>> remove_char((\"abc\"), 1)\n// (\"ac\")\n// >>> remove_char((\"abc\"), 0)\n// (\"bc\")\n// >>> remove_char((\"abc\"), 2)\n// (\"ab\")\nstd::string remove_char(std::string string, long index) {\n    return string.erase(index, 1);\n}\n\n// Return the string with the given character appended to the end\n// >>> append_char((\"abc\"), ('d'))\n// (\"abcd\")\n// >>> append_char((\"abc\"), ('a"}
{"task_id": "HumanEval_89_encrypt", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n\n    std::string result = \"\";\n    for (int i = 0; i < s.length(); i++) {\n        result += (char) (((s[i] - 'a') * 2 * 2 + 'a') % 26 + 'a');\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string result = \"\";\n    for (int i = 0; i < s.length(); i++) {\n        result += (char) (((s[i] - 'a') * 2 * 2 + 'a') % 26 + 'a');\n    }\n    return result;\n}\n\nint main() {\n    assert(encrypt(\"hi\") == \"lm\");\n    assert(encrypt(\"asdfghjkl\") == \"ewhjklnop\");\n    assert(encrypt(\"gf\") == \"kj\");\n    assert(encrypt(\"et\") == \"ix\");\n    return 0;\n}"}
{"task_id": "HumanEval_95_check_dict_case", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n\n    if (dict.empty()) {\n        return false;\n    }\n    bool lower_case = true;\n    bool upper_case = true;\n    for (auto it = dict.begin(); it != dict.end(); it++) {\n        if (it->first[0] >= 'A' && it->first[0] <= 'Z') {\n            lower_case = false;\n        } else if (it->first[0] >= 'a' && it->first[0] <= 'z') {\n            upper_case = false;\n        } else {\n            return false;\n        }\n    }\n    return lower_case || upper_case;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    bool lower_case = true;\n    bool upper_case = true;\n    for (auto it = dict.begin(); it != dict.end(); it++) {\n        if (it->first[0] >= 'A' && it->first[0] <= 'Z') {\n            lower_case = false;\n        } else if (it->first[0] >= 'a' && it->first[0] <= 'z') {\n            upper_case = false;\n        } else {\n            return false;\n        }\n    }\n    return lower_case || upper_case;\n}\n\nint main() {\n    assert(check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}}))) == true);\n    assert(check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == false);\n    assert(check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}}))) == false);\n    assert(check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == false);\n    assert(check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}))) == true);\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_85_add", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n\n    long sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    assert(add(std::vector<long>({(long)4, (long)2, (long)6, (long)7})) == 2);\n    assert(add(std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})) == 6);\n    assert(add(std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})) == 6);\n    assert(add(std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})) == 6);\n    assert(add(std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8})) == 12);\n    assert(add(std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})) == 12);\n    assert(add(std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10})) == 12);\n    assert(add(std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11})) == 12);\n    assert(add(std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6"}
{"task_id": "HumanEval_140_fix_spaces", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n\n    std::string result;\n    int count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            count++;\n        } else {\n            if (count > 2) {\n                result += '-';\n            } else if (count > 0) {\n                result += std::string(count, '_');\n            }\n            result += c;\n            count = 0;\n        }\n    }\n    if (count > 2) {\n        result += '-';\n    } else if (count > 0) {\n        result += std::string(count, '_');\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            count++;\n        } else {\n            if (count > 2) {\n                result += '-';\n            } else if (count > 0) {\n                result += std::string(count, '_');\n            }\n            result += c;\n            count = 0;\n        }\n    }\n    if (count > 2) {\n        result += '-';\n    } else if (count > 0) {\n        result += std::string(count, '_');\n    }\n    return result;\n}\n\nint main() {\n    assert(fix_spaces(\" Example\") == \"Example\");\n    assert(fix_spaces(\" Example 1\") == \"Example_1\");\n    assert(fix_spaces(\" Example 2\") == \"_Example_2\");\n    assert(fix_spaces(\" Example 3\") == \"_Example-3\");\n    std::cout << \"All test cases passed successfully!\" << std::endl;\n}"}
{"task_id": "HumanEval_63_fibfib", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n    long a = 0, b = 0, c = 1, d;\n    for (long i = 3; i <= n; i++) {\n        d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    return c;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n    long a = 0, b = 0, c = 1, d;\n    for (long i = 3; i <= n; i++) {\n        d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    return c;\n}\n\nint main() {\n    assert(fibfib(1) == 0);\n    assert(fibfib(5) == 4);\n    assert(fibfib(8) == 24);\n    std::cout << \"Passed!\" << std::endl;\n}"}
{"task_id": "HumanEval_151_double_the_difference", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n\n    long sum = 0;\n    for (auto i : lst) {\n        if (i > 0 && i == (long)i && i % 2 == 1) {\n            sum += i * i;\n        }\n    }\n    return sum;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (auto i : lst) {\n        if (i > 0 && i == (long)i && i % 2 == 1) {\n            sum += i * i;\n        }\n    }\n    return sum;\n}\n\nint main() {\n    assert(double_the_difference(std::vector<float>({(long)1, (long)3, (long)2, (long)0})) == 10);\n    assert(double_the_difference(std::vector<float>({(long)-1, (long)-2, (long)0})) == 0);\n    assert(double_the_difference(std::vector<float>({(long)9, (long)-2})) == 81);\n    assert(double_the_difference(std::vector<float>({(long)0})) == 0);\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_22_filter_integers", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n\n    std::vector<long> result;\n    for (auto value : values) {\n        if (value.type() == typeid(long)) {\n            result.push_back(std::any_cast<long>(value));\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (auto value : values) {\n        if (value.type() == typeid(long)) {\n            result.push_back(std::any_cast<long>(value));\n        }\n    }\n    return result;\n}\n\n// Filter given vector of any cppthon values only for strings\n// >>> filter_strings((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<std::string>({(std::string)\"a\"}))\n// >>> filter_strings((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<std::string>({(std::string)\"abc\"}))\nstd::vector<std::string> filter_strings(std::vector<std::any> values) {\n    std::vector<std::string> result;\n    for (auto value : values) {\n        if (value.type() == typeid(std::string)) {\n            result.push_back(std::any_cast<std::string>(value));\n        }\n    }\n    return result;\n}\n\n// Filter given vector of any cppthon values only for floats\n// >>> filter_floats((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<float>({(float)3.14}))\n// >>> filter_floats((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<float>())\nstd::vector<float> filter_floats(std::vector<std::any> values) {\n    std::vector<float> result;\n    for (auto value : values) {\n        if (value.type() == typeid(float)) {\n            result.push_back(std::any_cast<float>(value));\n        }\n    }\n    return result;\n}\n\n// Filter given vector of any cppthon values only for maps\n// >>> filter_maps((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<std::map<long,long>>())\n// >>> filter_maps((std::vector<std::any>({1, "}
{"task_id": "HumanEval_41_car_race_collision", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n\n    return n*n;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    return n*n;\n}\n\nint main() {\n    assert(car_race_collision(0) == 0);\n    assert(car_race_collision(1) == 1);\n    assert(car_race_collision(2) == 4);\n    assert(car_race_collision(3) == 9);\n    assert(car_race_collision(4) == 16);\n    assert(car_race_collision(5) == 25);\n    assert(car_race_collision(6) == 36);\n    assert(car_race_collision(7) == 49);\n    assert(car_race_collision(8) == 64);\n    assert(car_race_collision(9) == 81);\n    assert(car_race_collision(10) == 100);\n    assert(car_race_collision(11) == 121);\n    assert(car_race_collision(12) == 144);\n    assert(car_race_collision(13) == 169);\n    assert(car_race_collision(14) == 196);\n    assert(car_race_collision(15) == 225);\n    assert(car_race_collision(16) == 256);\n    assert(car_race_collision(17) == 289);\n    assert(car_race_collision(18) == 324);\n    assert(car_race_collision(19) == 361);\n    assert(car_race_collision(20) == 400);\n    assert(car_race_collision(21) == 441);\n    assert(car_race_collision(22) == 484);\n    assert(car_race_collision(23) == 529);\n    assert(car_race_collision(24) == 576);\n    assert(car_race_collision(25) == 625);\n    assert(car_race_collision(26) == 676);\n    assert(car_race_collision(27) == 729);\n    assert(car_race_collision(28) == 784);\n    assert(car_race_collision(29) == 841);\n    assert(car_race_collision(30) == 900);\n    assert(car_race_collision(31) == 961);\n    assert(car_race_collision(32) == 1024);\n    assert(car_race_collision(33) == 1089);\n    assert"}
{"task_id": "HumanEval_17_parse_music", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n\n    std::vector<long> result;\n    std::string note;\n    for (char c : music_string) {\n        if (c == ' ') {\n            if (note == \"o\") {\n                result.push_back(4);\n            } else if (note == \"o|\") {\n                result.push_back(2);\n            } else if (note == \".|\") {\n                result.push_back(1);\n            }\n            note = \"\";\n        } else {\n            note += c;\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::string note;\n    for (char c : music_string) {\n        if (c == ' ') {\n            if (note == \"o\") {\n                result.push_back(4);\n            } else if (note == \"o|\") {\n                result.push_back(2);\n            } else if (note == \".|\") {\n                result.push_back(1);\n            }\n            note = \"\";\n        } else {\n            note += c;\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert((parse_music((\"o o| .| o| o| .| .| .| .| o o\")) == std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4})));\n    assert((parse_music((\"o o| .| o| o| .| .| .| .| o o\")) == std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4})));\n    assert((parse_music((\"o o| .| o| o| .| .| .| .| o o\")) == std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4})));\n    assert((parse_music((\"o o| .| o| o| .| .| .| .| o o\")) == std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4})));\n    assert((parse_music((\"o o| .| o| o| .| .| .| .| o o\")) == std::vector<long>({(long)"}
{"task_id": "HumanEval_79_decimal_to_binary", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n\n    std::string binary = \"db\";\n    if (decimal == 0) {\n        binary += \"0\";\n    } else {\n        while (decimal > 0) {\n            binary = std::to_string(decimal % 2) + binary;\n            decimal /= 2;\n        }\n    }\n    binary += \"db\";\n    return binary;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"db\";\n    if (decimal == 0) {\n        binary += \"0\";\n    } else {\n        while (decimal > 0) {\n            binary = std::to_string(decimal % 2) + binary;\n            decimal /= 2;\n        }\n    }\n    binary += \"db\";\n    return binary;\n}\n\nint main() {\n    assert(decimal_to_binary(15) == \"db1111db\");\n    assert(decimal_to_binary(32) == \"db100000db\");\n    assert(decimal_to_binary(0) == \"db0db\");\n    assert(decimal_to_binary(1) == \"db1db\");\n    assert(decimal_to_binary(2) == \"db10db\");\n    assert(decimal_to_binary(3) == \"db11db\");\n    assert(decimal_to_binary(4) == \"db100db\");\n    assert(decimal_to_binary(5) == \"db101db\");\n    assert(decimal_to_binary(6) == \"db110db\");\n    assert(decimal_to_binary(7) == \"db111db\");\n    assert(decimal_to_binary(8) == \"db1000db\");\n    assert(decimal_to_binary(9) == \"db1001db\");\n    assert(decimal_to_binary(10) == \"db1010db\");\n    assert(decimal_to_binary(11) == \"db1011db\");\n    assert(decimal_to_binary(12) == \"db1100db\");\n    assert(decimal_to_binary(13) == \"db1101db\");\n    assert(decimal_to_binary(14) == \"db1110db\");\n    assert(decimal_to_binary(15) == \"db1111db\");\n    assert(decimal_to_binary(16) == \"db10000db\");\n    assert(decimal_to_binary(17) == \"db10001db\");\n    assert(decimal_to_binary(18) == \"db10010db\");\n    assert(decimal_to_binary(19) == \"db10011db\");\n    assert(decimal_to_binary(20) == \"db10100db\");\n    assert(decimal_to_binary(21) == \"db10101db\");\n    assert(decimal_to_binary(2"}
{"task_id": "HumanEval_14_all_prefixes", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.length(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.length(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;\n}\n\n// Return vector of all suffixes from shortest to longest of the input string\n// >>> all_suffixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bc\", (std::string)\"c\"}))\nstd::vector<std::string> all_suffixes(std::string string) {\n    std::vector<std::string> suffixes;\n    for (int i = string.length() - 1; i >= 0; i--) {\n        suffixes.push_back(string.substr(i, string.length() - i));\n    }\n    return suffixes;\n}\n\n// Return vector of all substrings of the input string\n// >>> all_substrings((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\", (std::string)\"b\", (std::string)\"bc\", (std::string)\"c\"}))\nstd::vector<std::string> all_substrings(std::string string) {\n    std::vector<std::string> substrings;\n    for (int i = 0; i < string.length(); i++) {\n        for (int j = i + 1; j <= string.length(); j++) {\n            substrings.push_back(string.substr(i, j - i));\n        }\n    }\n    return substrings;\n}\n\n// Return vector of all substrings of the input string that are palindromes\n// >>> all_palindromic_substrings((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"}))\nstd::vector<std::string> all_palindromic_substrings(std::string string) {\n    std::vector<std::string> palindromic_substrings;\n    for (int i = 0; i < string.length(); i++) {\n        for (int j = i + 1; j <= string.length(); j++) {\n            std::string substring = string.substr(i, j - i);\n            if (substring == std::string(substring.rbegin(), substring.rend())) {\n                palindrom"}
{"task_id": "HumanEval_53_add", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n\n    return x + y;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;\n}\n\n// Subtract two numbers x and y\n// >>> subtract((2), (3))\n// (-1)\n// >>> subtract((5), (7))\n// (-2)\nlong subtract(long x, long y) {\n    return x - y;\n}\n\n// Multiply two numbers x and y\n// >>> multiply((2), (3))\n// (6)\n// >>> multiply((5), (7))\n// (35)\nlong multiply(long x, long y) {\n    return x * y;\n}\n\n// Divide two numbers x and y\n// >>> divide((2), (3))\n// (0)\n// >>> divide((5), (7))\n// (0)\nlong divide(long x, long y) {\n    return x / y;\n}\n\n// Find the remainder of two numbers x and y\n// >>> remainder((2), (3))\n// (2)\n// >>> remainder((5), (7))\n// (5)\nlong remainder(long x, long y) {\n    return x % y;\n}\n\n// Find the power of a number x raised to y\n// >>> power((2), (3))\n// (8)\n// >>> power((5), (7))\n// (78125)\nlong power(long x, long y) {\n    return pow(x, y);\n}\n\n// Find the square root of a number x\n// >>> square_root((4))\n// (2)\n// >>> square_root((9))\n// (3)\nlong square_root(long x) {\n    return sqrt(x);\n}\n\n// Find the factorial of a number x\n// >>> factorial((4))\n// (24)\n// >>> factorial((5))\n// (120)\nlong factorial(long x) {\n    return tgamma(x + 1);\n}\n\n// Find the absolute value of a number x\n// >>> absolute((4))\n// (4)\n// >>> absolute((-4))\n// (4)\nlong absolute(long x) {\n    return abs(x);\n}\n\n// Find the maximum of two numbers x and y\n// >>> maximum((2), (3))\n// (3)\n// >>> maximum((5), (7))\n// (7)\nlong maximum(long x, long y) {\n    return max(x, y);\n}\n\n// Find the minimum of two numbers x and y\n// >>> minimum((2), (3))\n// (2)\n// >>> minimum((5), (7))\n// (5)\nlong minimum(long x"}
{"task_id": "HumanEval_159_eat", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n\n    long eaten = number + need;\n    long left = remaining - need;\n    if (left < 0) {\n        eaten -= left;\n        left = 0;\n    }\n    return std::vector<long>({eaten, left});", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = number + need;\n    long left = remaining - need;\n    if (left < 0) {\n        eaten -= left;\n        left = 0;\n    }\n    return std::vector<long>({eaten, left});\n}"}
{"task_id": "HumanEval_115_max_fill", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n\n    long res = 0;\n    for (auto &row : grid) {\n        long count = 0;\n        for (auto &cell : row) {\n            count += cell;\n        }\n        res += (count + capacity - 1) / capacity;\n    }\n    return res;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long res = 0;\n    for (auto &row : grid) {\n        long count = 0;\n        for (auto &cell : row) {\n            count += cell;\n        }\n        res += (count + capacity - 1) / capacity;\n    }\n    return res;\n}"}
{"task_id": "HumanEval_160_do_algebra", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n\n    std::stack<long> st;\n    for (int i = 0; i < operand.size(); i++) {\n        if (i < op.size()) {\n            if (op[i] == \"+\") {\n                long a = st.top();\n                st.pop();\n                long b = operand[i];\n                st.push(a + b);\n            } else if (op[i] == \"-\") {\n                long a = st.top();\n                st.pop();\n                long b = operand[i];\n                st.push(a - b);\n            } else if (op[i] == \"*\") {\n                long a = st.top();\n                st.pop();\n                long b = operand[i];\n                st.push(a * b);\n            } else if (op[i] == \"//\") {\n                long a = st.top();\n                st.pop();\n                long b = operand[i];\n                st.push(a / b);\n            } else if (op[i] == \"**\") {\n                long a = st.top();\n                st.pop();\n                long b = operand[i];\n                st.push(pow(a, b));\n            }\n        } else {\n            st.push(operand[i]);\n        }\n    }\n    return st.top();", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    std::stack<long> st;\n    for (int i = 0; i < operand.size(); i++) {\n        if (i < op.size()) {\n            if (op[i] == \"+\") {\n                long a = st.top();\n                st.pop();\n                long b = operand[i];\n                st.push(a + b);\n            } else if (op[i] == \"-\") {\n                long a = st.top();\n                st.pop();\n                long b = operand[i];\n                st.push(a - b);\n            } else if (op[i] == \"*\") {\n                long a = st.top();\n                st.pop();\n                long b = operand[i];\n                st.push(a * b);\n            } else if (op[i] == \"//\") {\n                long a = st.top();\n                st.pop();\n                long b = operand[i];\n                st.push(a / b);\n            } else if (op[i] == \"**\") {\n                long a = st.top();\n                st.pop();\n                long b = operand[i];\n                st.push(pow(a, b));\n            }\n        } else {\n            st.push(operand[i]);\n        }\n    }\n    return st.top();\n}"}
{"task_id": "HumanEval_27_flip_case", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n\n    std::string result = \"\";\n    for (char c : string) {\n        if (islower(c)) {\n            result += toupper(c);\n        } else {\n            result += tolower(c);\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::string result = \"\";\n    for (char c : string) {\n        if (islower(c)) {\n            result += toupper(c);\n        } else {\n            result += tolower(c);\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert(flip_case(\"Hello\") == \"hELLO\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"12345\") == \"12345\");\n    assert(flip_case(\"AbCdEf\") == \"aBcDeF\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"AbCdEf\");\n    assert(flip_case(\"aBcDeF\") == \"Ab"}
{"task_id": "HumanEval_105_by_length", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n\n  std::vector<std::string> result;\n  std::map<long, std::string> m = {{1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n  for (auto i : arr) {\n    if (i >= 1 && i <= 9) {\n      result.push_back(m[i]);\n    }\n  }\n  std::reverse(result.begin(), result.end());\n  return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<std::string> result;\n  std::map<long, std::string> m = {{1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n  for (auto i : arr) {\n    if (i >= 1 && i <= 9) {\n      result.push_back(m[i]);\n    }\n  }\n  std::reverse(result.begin(), result.end());\n  return result;\n}\nint main() {\n  assert((by_length(std::vector<long>({2, 1, 1, 4, 5, 8, 2, 3})) == std::vector<std::string>({\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"})));\n  assert((by_length(std::vector<long>({})) == std::vector<std::string>({})));\n  assert((by_length(std::vector<long>({1, -1, 55})) == std::vector<std::string>({\"One\"})));\n  std::cout << \"Success\" << std::endl;\n  return 0;\n}"}
{"task_id": "HumanEval_25_factorize", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n\n    std::vector<long> factors;\n    for (long i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    for (long i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\nint main() {\n    assert((factorize(8) == std::vector<long>({2, 2, 2})));\n    assert((factorize(25) == std::vector<long>({5, 5})));\n    assert((factorize(70) == std::vector<long>({2, 5, 7})));\n    std::cout << \"tests passed\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_96_count_up_to", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n\n    std::vector<long> primes;\n    for (long i = 2; i < n; i++) {\n        bool is_prime = true;\n        for (long j = 2; j * j <= i; j++) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    for (long i = 2; i < n; i++) {\n        bool is_prime = true;\n        for (long j = 2; j * j <= i; j++) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\nint main() {\n    assert(count_up_to(5) == std::vector<long>({2, 3}));\n    assert(count_up_to(11) == std::vector<long>({2, 3, 5, 7}));\n    assert(count_up_to(0) == std::vector<long>());\n    assert(count_up_to(20) == std::vector<long>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1) == std::vector<long>());\n    assert(count_up_to(18) == std::vector<long>({2, 3, 5, 7, 11, 13, 17}));\n    return 0;\n}"}
{"task_id": "HumanEval_34_unique", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;\n}\n\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;\n}\n\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;\n}\n\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;\n}\n\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5,"}
{"task_id": "HumanEval_74_total_match", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n\n    int sum1 = 0, sum2 = 0;\n    for (auto s : lst1) sum1 += s.size();\n    for (auto s : lst2) sum2 += s.size();\n    return sum1 < sum2 ? lst1 : lst2;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int sum1 = 0, sum2 = 0;\n    for (auto s : lst1) sum1 += s.size();\n    for (auto s : lst2) sum2 += s.size();\n    return sum1 < sum2 ? lst1 : lst2;\n}\n\nint main() {\n    assert((total_match(std::vector<std::string>(), std::vector<std::string>()) == std::vector<std::string>()));\n    assert((total_match(std::vector<std::string>({\"hi\", \"admin\"}), std::vector<std::string>({\"hI\", \"Hi\"})) == std::vector<std::string>({\"hI\", \"Hi\"})));\n    assert((total_match(std::vector<std::string>({\"hi\", \"admin\"}), std::vector<std::string>({\"hi\", \"hi\", \"admin\", \"project\"})) == std::vector<std::string>({\"hi\", \"admin\"})));\n    assert((total_match(std::vector<std::string>({\"hi\", \"admin\"}), std::vector<std::string>({\"hI\", \"hi\", \"hi\"})) == std::vector<std::string>({\"hI\", \"hi\", \"hi\"})));\n    assert((total_match(std::vector<std::string>({\"4\"}), std::vector<std::string>({\"1\", \"2\", \"3\", \"4\", \"5\"})) == std::vector<std::string>({\"4\"})));\n}"}
{"task_id": "HumanEval_35_max_element", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;\n}\n\n// Return minimum element in the vector.\n// >>> min_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (1)\n// >>> min_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (-10)\nlong min_element(std::vector<long> l) {\n    long min = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] < min) {\n            min = l[i];\n        }\n    }\n    return min;\n}\n\n// Return the sum of all elements in the vector.\n// >>> sum((std::vector<long>({(long)1, (long)2, (long)3})))\n// (6)\n// >>> sum((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (130)\nlong sum(std::vector<long> l) {\n    long sum = 0;\n    for (long i = 0; i < l.size(); i++) {\n        sum += l[i];\n    }\n    return sum;\n}\n\n// Return the product of all elements in the vector.\n// >>> product((std::vector<long>({(long)1, (long)2, (long)3})))\n// (6)\n// >>> product((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (0)\nlong product(std::"}
{"task_id": "HumanEval_132_is_nested", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n\n    int count = 0;\n    for (char c : string) {\n        if (c == '[') {\n            count++;\n        } else if (c == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (char c : string) {\n        if (c == '[') {\n            count++;\n        } else if (c == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n\nint main() {\n    assert(is_nested(\"[[]]\") == true);\n    assert(is_nested(\"[]]]]]]][[[[[]\") == false);\n    assert(is_nested(\"[][]\") == false);\n    assert(is_nested(\"[]\") == false);\n    assert(is_nested(\"[[][]]\") == true);\n    assert(is_nested(\"[[[]]\") == true);\n    std::cout << \"All tests passed successfully!\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_103_rounded_avg", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n\n    if (n > m) return -1;\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = round(sum / (m - n + 1.0));\n    return std::to_string(avg);", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) return -1;\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = round(sum / (m - n + 1.0));\n    return std::to_string(avg);\n}\n\nint main() {\n    assert(rounded_avg(1, 5) == \"0b11\");\n    assert(rounded_avg(7, 5) == -1);\n    assert(rounded_avg(10, 20) == \"0b1111\");\n    assert(rounded_avg(20, 33) == \"0b11010\");\n    std::cout << \"All tests passed.\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_113_odd_count", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n\n    std::vector<std::string> result;\n    for (auto s : lst) {\n        int count = 0;\n        for (auto c : s) {\n            if (c % 2 == 1) {\n                count++;\n            }\n        }\n        result.push_back(\"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\");\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto s : lst) {\n        int count = 0;\n        for (auto c : s) {\n            if (c % 2 == 1) {\n                count++;\n            }\n        }\n        result.push_back(\"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\");\n    }\n    return result;\n}\n\nint main() {\n    assert((odd_count(std::vector<std::string>({std::string(\"1234567\")})) == std::vector<std::string>({std::string(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")})));\n    assert((odd_count(std::vector<std::string>({std::string(\"3\"), std::string(\"11111111\")})) == std::vector<std::string>({std::string(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), std::string(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")})));\n    std::cout << \"All cases passed\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_109_move_one_ball", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n\n    int n = arr.size();\n    if(n == 0) return true;\n    int i = 0;\n    while(i < n && arr[i] < arr[i+1]) i++;\n    if(i == n-1) return true;\n    int j = i+1;\n    while(j < n && arr[j] < arr[j+1]) j++;\n    if(j == n-1) return true;\n    return false;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if(n == 0) return true;\n    int i = 0;\n    while(i < n && arr[i] < arr[i+1]) i++;\n    if(i == n-1) return true;\n    int j = i+1;\n    while(j < n && arr[j] < arr[j+1]) j++;\n    if(j == n-1) return true;\n    return false;\n}"}
{"task_id": "HumanEval_107_even_odd_palindrome", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n\n    long even = 0, odd = 0;\n    for (long i = 1; i <= n; i++) {\n        std::string s = std::to_string(i);\n        std::string r = s;\n        std::reverse(r.begin(), r.end());\n        if (s == r) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return std::make_tuple(even, odd);", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even = 0, odd = 0;\n    for (long i = 1; i <= n; i++) {\n        std::string s = std::to_string(i);\n        std::string r = s;\n        std::reverse(r.begin(), r.end());\n        if (s == r) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return std::make_tuple(even, odd);\n}\nint main() {\n    assert(even_odd_palindrome(3) == std::make_tuple(1, 2));\n    assert(even_odd_palindrome(12) == std::make_tuple(4, 6));\n    assert(even_odd_palindrome(100) == std::make_tuple(18, 82));\n    assert(even_odd_palindrome(1000) == std::make_tuple(180, 820));\n    assert(even_odd_palindrome(10000) == std::make_tuple(1800, 8200));\n    assert(even_odd_palindrome(100000) == std::make_tuple(18000, 82000));\n    assert(even_odd_palindrome(1000000) == std::make_tuple(180000, 820000));\n    assert(even_odd_palindrome(10000000) == std::make_tuple(1800000, 8200000));\n    assert(even_odd_palindrome(100000000) == std::make_tuple(18000000, 82000000));\n    assert(even_odd_palindrome(1000000000) == std::make_tuple(180000000, 820000000));\n    assert(even_odd_palindrome(10000000000) == std::make_tuple(1800000000, 8200000000));\n    assert(even_odd_palindrome(100000"}
{"task_id": "HumanEval_138_is_equal_to_sum_even", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n\n    if(n%2==0 && n>=8){\n        return true;\n    }\n    return false;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    if(n%2==0 && n>=8){\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    assert(is_equal_to_sum_even(4) == false);\n    assert(is_equal_to_sum_even(6) == false);\n    assert(is_equal_to_sum_even(8) == true);\n    assert(is_equal_to_sum_even(10) == true);\n    assert(is_equal_to_sum_even(12) == true);\n    assert(is_equal_to_sum_even(14) == true);\n    assert(is_equal_to_sum_even(16) == true);\n    assert(is_equal_to_sum_even(18) == true);\n    assert(is_equal_to_sum_even(20) == true);\n    assert(is_equal_to_sum_even(22) == true);\n    assert(is_equal_to_sum_even(24) == true);\n    assert(is_equal_to_sum_even(26) == true);\n    assert(is_equal_to_sum_even(28) == true);\n    assert(is_equal_to_sum_even(30) == true);\n    assert(is_equal_to_sum_even(32) == true);\n    assert(is_equal_to_sum_even(34) == true);\n    assert(is_equal_to_sum_even(36) == true);\n    assert(is_equal_to_sum_even(38) == true);\n    assert(is_equal_to_sum_even(40) == true);\n    assert(is_equal_to_sum_even(42) == true);\n    assert(is_equal_to_sum_even(44) == true);\n    assert(is_equal_to_sum_even(46) == true);\n    assert(is_equal_to_sum_even(48) == true);\n    assert(is_equal_to_sum_even(50) == true);\n    assert(is_equal_to_sum_even(52) == true);\n    assert(is_equal_to_sum_even(54) == true);\n    assert(is_equal_to_sum_even(56) == true);\n    assert(is_equal_to_sum_even(58) == true);\n    assert(is_equal_to_sum_even(60) == true);\n    assert(is_equal_to_sum_even(62) == true);\n    assert(is_equal_to_sum_even(64) == true);\n    assert(is_equal_to_sum_even(66) == true);\n    assert(is_equal_to_sum_even(68) == true);\n    assert(is_equal_to_sum_even(70) == true);\n"}
{"task_id": "HumanEval_62_derivative", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n\n    std::vector<long> res;\n    for (int i = 1; i < xs.size(); i++) {\n        res.push_back(xs[i] * i);\n    }\n    return res;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> res;\n    for (int i = 1; i < xs.size(); i++) {\n        res.push_back(xs[i] * i);\n    }\n    return res;\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return integral of this polynomial in the same form.\n// >>> integral((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)0, (long)3, (long)0.5, (long)0.6666666666666666, (long)1, (long)1.25}))\n// >>> integral((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)0, (long)1, (long)1, (long)1}))\nstd::vector<double> integral(std::vector<long> xs) {\n    std::vector<double> res;\n    res.push_back(0);\n    for (int i = 0; i < xs.size(); i++) {\n        res.push_back(xs[i] / (i + 1.0));\n    }\n    return res;\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return the value of this polynomial at x.\n// >>> evaluate((std::vector<long>({(long)1, (long)2, (long)3})), 10)\n// (long)33\n// >>> evaluate((std::vector<long>({(long)1, (long)2, (long)3})), 0)\n// (long)1\nlong evaluate(std::vector<long> xs, long x) {\n    long res = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        res += xs[i] * pow(x, i);\n    }\n    return res;\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 +"}
{"task_id": "HumanEval_126_is_sorted", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n\n  if (lst.size() == 0) {\n    return true;\n  }\n  long prev = lst[0];\n  for (long i = 1; i < lst.size(); i++) {\n    if (lst[i] < prev) {\n      return false;\n    }\n    prev = lst[i];\n  }\n  return true;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  if (lst.size() == 0) {\n    return true;\n  }\n  long prev = lst[0];\n  for (long i = 1; i < lst.size(); i++) {\n    if (lst[i] < prev) {\n      return false;\n    }\n    prev = lst[i];\n  }\n  return true;\n}\n\nint main() {\n  assert(is_sorted(std::vector<long>({(long)5})) == true);\n  assert(is_sorted(std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})) == true);\n  assert(is_sorted(std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})) == false);\n  assert(is_sorted(std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})) == true);\n  assert(is_sorted(std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})) == true);\n  assert(is_sorted(std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})) == false);\n  assert(is_sorted(std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})) == true);\n  assert(is_sorted(std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})) == false);\n  std::cout << \"All tests passed.\" << std::endl;\n  return 0;\n}"}
{"task_id": "HumanEval_161_solve", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n\n    std::string result = s;\n    bool hasLetter = false;\n    for (int i = 0; i < s.size(); i++) {\n        if (isalpha(s[i])) {\n            hasLetter = true;\n            if (isupper(s[i])) {\n                result[i] = tolower(s[i]);\n            } else {\n                result[i] = toupper(s[i]);\n            }\n        }\n    }\n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    std::string result = s;\n    bool hasLetter = false;\n    for (int i = 0; i < s.size(); i++) {\n        if (isalpha(s[i])) {\n            hasLetter = true;\n            if (isupper(s[i])) {\n                result[i] = tolower(s[i]);\n            } else {\n                result[i] = toupper(s[i]);\n            }\n        }\n    }\n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    }\n    return result;\n}\n\nint main() {\n    assert(solve(\"1234\") == \"4321\");\n    assert(solve(\"ab\") == \"AB\");\n    assert(solve(\"#a@C\") == \"#A@c\");\n    assert(solve(\"12345\") == \"54321\");\n    assert(solve(\"abc\") == \"ABC\");\n    assert(solve(\"Abc\") == \"aBC\");\n    assert(solve(\"aBc\") == \"AbC\");\n    assert(solve(\"aBcD\") == \"AbCd\");\n    assert(solve(\"aBcD1234\") == \"AbCd4321\");\n    assert(solve(\"aBcD1234!\") == \"!4321dCbA\");\n    assert(solve(\"aBcD1234!@#$%^&*()_+\") == \"+_)(*&^%$#@!4321dCbA\");\n    assert(solve(\"aBcD1234!@#$%^&*()_+ aBcD1234!@#$%^&*()_+\") == \"+_)(*&^%$#@!4321dCbA +_)(*&^%$#@!4321dCbA\");\n    assert(solve(\"aBcD1234!@#$%^&*()_+ aBcD1234!@#$%^&*()_+ aBcD1234!@#$%^&*()_+\") == \"+_)(*&^%$#@!4321dCbA +_)(*&^%$#@!4321dCbA +_)(*&^%$#@!4321dCbA\");\n    assert(solve(\"a"}
{"task_id": "HumanEval_130_tri", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n\n    std::vector<long> result;\n    result.push_back(3);\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            result.push_back(1 + i / 2);\n        } else {\n            result.push_back(result[i - 1] + result[i - 2] + result[i + 1]);\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> result;\n    result.push_back(3);\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            result.push_back(1 + i / 2);\n        } else {\n            result.push_back(result[i - 1] + result[i - 2] + result[i + 1]);\n        }\n    }\n    return result;\n}\nint main() {\n    assert((tri(3) == std::vector<long>({1, 3, 2, 8})));\n    assert((tri(4) == std::vector<long>({1, 3, 2, 8, 13})));\n    assert((tri(5) == std::vector<long>({1, 3, 2, 8, 13, 21})));\n    assert((tri(6) == std::vector<long>({1, 3, 2, 8, 13, 21, 34})));\n    assert((tri(7) == std::vector<long>({1, 3, 2, 8, 13, 21, 34, 55})));\n    assert((tri(8) == std::vector<long>({1, 3, 2, 8, 13, 21, 34, 55, 89})));\n    assert((tri(9) == std::vector<long>({1, 3, 2, 8, 13, 21, 34, 55, 89, 144})));\n    assert((tri(10) == std::vector<long>({1, 3, 2, 8, 13, 21, 34, 55, 89, 144, 233})));\n    assert((tri(11) == std::vector<long>({1, 3, 2, 8, 13, 21, 34, 55, 89, 144, 233, 377})));\n    assert((tri(12) == std::vector<long>({1, 3, 2, 8, 1"}
{"task_id": "HumanEval_36_fizz_buzz", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            std::string s = std::to_string(i);\n            for (char c : s) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            std::string s = std::to_string(i);\n            for (char c : s) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    assert(fizz_buzz(50) == 0);\n    assert(fizz_buzz(78) == 2);\n    assert(fizz_buzz(79) == 3);\n    std::cout << \"All test cases passed successfully.\" << std::endl;\n}"}
{"task_id": "HumanEval_29_filter_by_prefix", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n\n    std::vector<std::string> result;\n    for (auto s : strings) {\n        if (s.find(prefix) == 0) {\n            result.push_back(s);\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    for (auto s : strings) {\n        if (s.find(prefix) == 0) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert((filter_by_prefix(std::vector<std::string>(), \"a\") == std::vector<std::string>()));\n    assert((filter_by_prefix(std::vector<std::string>{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\") == std::vector<std::string>{\"abc\", \"array\"}));\n    std::cout << \"All test cases passed successfully!\" << std::endl;\n}"}
{"task_id": "HumanEval_84_solve", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0  N  10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n\n    std::string result = \"\";\n    while (N > 0) {\n        result = std::to_string(N % 2) + result;\n        N /= 2;\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0  N  10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0  N  10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string result = \"\";\n    while (N > 0) {\n        result = std::to_string(N % 2) + result;\n        N /= 2;\n    }\n    return result;\n}\n\nint main() {\n    assert(solve(1000) == \"1\");\n    assert(solve(150) == \"110\");\n    assert(solve(147) == \"1100\");\n    std::cout << \"Pass test cases!\" << std::endl;\n}"}
{"task_id": "HumanEval_129_minPath", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int x = 0; x < n; x++) {\n                for (int y = 0; y < n; y++) {\n                    if (abs(i - x) + abs(j - y) == 1) {\n                        dp[x][y] = std::min(dp[x][y], dp[i][j] + grid[x][y]);\n                    }\n                }\n            }\n        }\n    }\n    std::vector<long> ans;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j] == grid[i][j]) {\n                ans.push_back(grid[i][j]);\n                k--;\n                if (k == 0) {\n                    return ans;\n                }\n                for (int x = 0; x < n; x++) {\n                    for (int y = 0; y < n; y++) {\n                        if (abs(i - x) + abs(j - y) == 1) {\n                            dp[x][y] = std::min(dp[x][y], dp[i][j] + grid[x][y]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return ans;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int x = 0; x < n; x++) {\n                for (int y = 0; y < n; y++) {\n                    if (abs(i - x) + abs(j - y) == 1) {\n                        dp[x][y] = std::min(dp[x][y], dp[i][j] + grid[x][y]);\n                    }\n                }\n            }\n        }\n    }\n    std::vector<long> ans;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j] == grid[i][j]) {\n                ans.push_back(grid[i][j]);\n                k--;\n                if (k == 0) {\n                    return ans;\n                }\n                for (int x = 0; x < n; x++) {\n                    for (int y = 0; y < n; y++) {\n                        if (abs(i - x) + abs(j - y) == 1) {\n                            dp[x][y] = std::min(dp[x][y], dp[i][j] + grid[x][y]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    assert((minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));\n    assert((min"}
{"task_id": "HumanEval_98_count_upper", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n\n    long count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (isupper(s[i]) && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (isupper(s[i]) && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    assert(count_upper(\"aBCdEf\") == 1);\n    assert(count_upper(\"abcdefg\") == 0);\n    assert(count_upper(\"dBBE\") == 0);\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_120_maximum", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n\n    std::vector<long> result;\n    std::sort(arr.begin(), arr.end());\n    for (long i = arr.size() - 1; i >= arr.size() - k; i--) {\n        result.push_back(arr[i]);\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::sort(arr.begin(), arr.end());\n    for (long i = arr.size() - 1; i >= arr.size() - k; i--) {\n        result.push_back(arr[i]);\n    }\n    return result;\n}\n\nint main() {\n    assert((maximum(std::vector<long>({(long)-3, (long)-4, (long)5}), (3)) == std::vector<long>({(long)-4, (long)-3, (long)5})));\n    assert((maximum(std::vector<long>({(long)4, (long)-4, (long)4}), (2)) == std::vector<long>({(long)4, (long)4})));\n    assert((maximum(std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1}), (1)) == std::vector<long>({(long)2})));\n    std::cout << \"All test cases passed\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_24_largest_divisor", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n\n    assert(n > 0);\n    for (long i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    for (long i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n\n// >>> largest_divisor(15)\n// (5)\n// >>> largest_divisor(100)\n// (50)\n// >>> largest_divisor(1)\n// (1)"}
{"task_id": "HumanEval_88_sort_array", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n\n    std::vector<long> result = array;\n    if (result.size() == 0) {\n        return result;\n    }\n    if ((result[0] + result[result.size() - 1]) % 2 == 0) {\n        std::sort(result.begin(), result.end(), std::greater<long>());\n    } else {\n        std::sort(result.begin(), result.end());\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    std::vector<long> result = array;\n    if (result.size() == 0) {\n        return result;\n    }\n    if ((result[0] + result[result.size() - 1]) % 2 == 0) {\n        std::sort(result.begin(), result.end(), std::greater<long>());\n    } else {\n        std::sort(result.begin(), result.end());\n    }\n    return result;\n}\n\nvoid test_sort_array() {\n    assert((sort_array(std::vector<long>()) == std::vector<long>()));\n    assert((sort_array(std::vector<long>({(long)5})) == std::vector<long>({(long)5})));\n    assert((sort_array(std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})) == std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));\n    assert((sort_array(std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})) == std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));\n}\n\nint main() {\n    test_sort_array();\n    std::cout << \"All tests passed.\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_106_f", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n\n    std::vector<long> result;\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result.push_back(factorial);\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result;\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result.push_back(factorial);\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert((f(5) == std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));\n    assert((f(1) == std::vector<long>({(long)1})));\n    assert((f(2) == std::vector<long>({(long)1, (long)2})));\n    assert((f(3) == std::vector<long>({(long)1, (long)2, (long)6})));\n    assert((f(4) == std::vector<long>({(long)1, (long)2, (long)6, (long)24})));\n    assert((f(6) == std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)120})));\n    std::cout << \"Good job\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_77_iscube", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n\n    if (a == 0) return true;\n    if (a < 0) a = -a;\n    long x = 1;\n    while (x * x * x < a) x++;\n    return x * x * x == a;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    if (a == 0) return true;\n    if (a < 0) a = -a;\n    long x = 1;\n    while (x * x * x < a) x++;\n    return x * x * x == a;\n}\nint main() {\n    assert(iscube(1) == true);\n    assert(iscube(2) == false);\n    assert(iscube(-1) == true);\n    assert(iscube(64) == true);\n    assert(iscube(0) == true);\n    assert(iscube(180) == false);\n    return 0;\n}"}
{"task_id": "HumanEval_93_encode", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n\n    std::string result = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c = c - 'a' + 'A';\n        } else if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            c = c - 'a' + 2 + 'a';\n        }\n        result += c;\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string result = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c = c - 'a' + 'A';\n        } else if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            c = c - 'a' + 2 + 'a';\n        }\n        result += c;\n    }\n    return result;\n}\n\nint main() {\n    assert(encode(\"test\") == \"TGST\");\n    assert(encode(\"This is a message\") == \"tHKS KS C MGSSCGG\");\n    return 0;\n}"}
{"task_id": "HumanEval_91_is_bored", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n\n    std::string temp = \"\";\n    int count = 0;\n    for (int i = 0; i < S.length(); i++) {\n        if (S[i] == 'I' && (S[i - 1] == '.' || S[i - 1] == '?' || S[i - 1] == '!')) {\n            count++;\n        }\n    }\n    return count;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    std::string temp = \"\";\n    int count = 0;\n    for (int i = 0; i < S.length(); i++) {\n        if (S[i] == 'I' && (S[i - 1] == '.' || S[i - 1] == '?' || S[i - 1] == '!')) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    assert(is_bored(\"Hello world\") == 0);\n    assert(is_bored(\"The sky is blue. The sun is shining. I love this weather\") == 1);\n    assert(is_bored(\"I am bored. I am tired. I am hungry. I am sad.\") == 4);\n    assert(is_bored(\"I am not bored. I am not tired. I am not hungry. I am not sad.\") == 0);\n    assert(is_bored(\"I am bored. I am not tired. I am not hungry. I am not sad.\") == 1);\n    assert(is_bored(\"I am not bored. I am tired. I am hungry. I am sad.\") == 0);\n    assert(is_bored(\"I am not bored. I am not tired. I am hungry. I am sad.\") == 0);\n    assert(is_bored(\"I am not bored. I am not tired. I am not hungry. I am sad.\") == 1);\n    assert(is_bored(\"I am not bored. I am not tired. I am not hungry. I am not sad.\") == 0);\n    assert(is_bored(\"I am bored. I am tired. I am hungry. I am sad.\") == 1);\n    assert(is_bored(\"I am not bored. I am tired. I am hungry. I am sad.\") == 0);\n    assert(is_bored(\"I am not bored. I am not tired. I am hungry. I am sad.\") == 0);\n    assert(is_bored(\"I am not bored. I am not tired. I am not hungry. I am sad.\") == 1);\n    assert(is_bored(\"I am bored. I am not tired. I am not hungry. I am not sad.\") == 1);\n    assert(is_bored(\"I am not bored. I am tired. I am hungry. I am sad.\") == 0);\n    assert(is_bored(\"I am not bored"}
{"task_id": "HumanEval_43_pairs_sum_to_zero", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n\n    std::set<long> s;\n    for (long i : l) {\n        if (s.find(-i) != s.end()) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::set<long> s;\n    for (long i : l) {\n        if (s.find(-i) != s.end()) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;\n}\n\nint main() {\n    assert(pairs_sum_to_zero(std::vector<long>({1, 3, 5, 0})) == false);\n    assert(pairs_sum_to_zero(std::vector<long>({1, 3, -2, 1})) == false);\n    assert(pairs_sum_to_zero(std::vector<long>({1, 2, 3, 7})) == false);\n    assert(pairs_sum_to_zero(std::vector<long>({2, 4, -5, 3, 5, 7})) == true);\n    assert(pairs_sum_to_zero(std::vector<long>({1})) == false);\n    std::cout << \"All tests passed successfully!\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_71_triangle_area", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n\n    if(a+b>c && a+c>b && b+c>a){\n        float s = (a+b+c)/2.0;\n        float area = sqrt(s*(s-a)*(s-b)*(s-c));\n        return area;\n    }\n    return -1;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if(a+b>c && a+c>b && b+c>a){\n        float s = (a+b+c)/2.0;\n        float area = sqrt(s*(s-a)*(s-b)*(s-c));\n        return area;\n    }\n    return -1;\n}\n\nint main() {\n    assert(fabs(triangle_area(3, 4, 5) - 6.0f) < 0.001);\n    assert(fabs(triangle_area(1, 2, 10) - -1) < 0.001);\n    assert(fabs(triangle_area(10, 5, 7) - 16.25f) < 0.001);\n    assert(fabs(triangle_area(8, 15, 7) - 27.21f) < 0.001);\n    assert(fabs(triangle_area(21, 15, 10) - 89.40f) < 0.001);\n    assert(fabs(triangle_area(14, 18, 4) - -1) < 0.001);\n    assert(fabs(triangle_area(4, 16, 12) - 23.71f) < 0.001);\n    assert(fabs(triangle_area(17, 14, 16) - 105.00f) < 0.001);\n    assert(fabs(triangle_area(6, 8, 10) - 24.00f) < 0.001);\n    assert(fabs(triangle_area(14, 10, 6) - 21.00f) < 0.001);\n    assert(fabs(triangle_area(14, 10, 16) - 47.50f) < 0.001);\n    assert(fabs(triangle_area(15, 17, 10) - 43.29f) < 0.001);\n    assert(fabs(triangle_area(17, 10, 15) - 43.29f) < 0.001);\n    assert(fabs(triangle_area(10, "}
{"task_id": "HumanEval_148_bf", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n    int index1 = -1, index2 = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n            index1 = i;\n        }\n        if (planets[i] == planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1 || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2) {\n        std::swap(index1, index2);\n    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n    int index1 = -1, index2 = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n            index1 = i;\n        }\n        if (planets[i] == planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1 || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2) {\n        std::swap(index1, index2);\n    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n}\nint main() {\n    assert(bf(\"Jupiter\", \"Neptune\") == std::vector<std::string>({\"Saturn\", \"Uranus\"}));\n    assert(bf(\"Earth\", \"Mercury\") == std::vector<std::string>({\"Venus\"}));\n    assert(bf(\"Mercury\", \"Uranus\") == std::vector<std::string>({\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}));\n    return 0;\n}"}
{"task_id": "HumanEval_131_digits", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n\n    long product = 1;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    if (product == 1) {\n        return 0;\n    }\n    return product;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    if (product == 1) {\n        return 0;\n    }\n    return product;\n}\n\nint main() {\n    assert(digits(1) == 1);\n    assert(digits(4) == 0);\n    assert(digits(235) == 15);\n    assert(digits(2468) == 0);\n    assert(digits(13579) == 945);\n    assert(digits(123456789) == 945);\n    assert(digits(1111111111) == 1);\n    assert(digits(2222222222) == 0);\n    assert(digits(1234567890) == 945);\n    assert(digits(111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}
{"task_id": "HumanEval_101_words_string", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n\n    std::vector<std::string> result;\n    std::string word;\n    for (char c : s) {\n        if (c == ',' || c == ' ') {\n            if (!word.empty()) {\n                result.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        result.push_back(word);\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> result;\n    std::string word;\n    for (char c : s) {\n        if (c == ',' || c == ' ') {\n            if (!word.empty()) {\n                result.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        result.push_back(word);\n    }\n    return result;\n}\n\nint main() {\n    assert((words_string(\"Hi, my name is John\") == std::vector<std::string>{\"Hi\", \"my\", \"name\", \"is\", \"John\"}));\n    assert((words_string(\"One, two, three, four, five, six\") == std::vector<std::string>{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n    assert((words_string(\"Hello, world\") == std::vector<std::string>{\"Hello\", \"world\"}));\n    assert((words_string(\"This is a test\") == std::vector<std::string>{\"This\", \"is\", \"a\", \"test\"}));\n    assert((words_string(\"One, two, three, four, five, six, seven, eight, nine, ten\") == std::vector<std::string>{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\"}));\n    assert((words_string(\"A quick brown fox jumps over the lazy dog\") == std::vector<std::string>{\"A\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\", \"the\", \"lazy\", \"dog\"}));\n    assert((words_string(\"The quick brown fox jumps over the lazy dog\") == std::vector<std::string>{\"The\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\", \"the\", \"lazy\", \"dog\"}));\n    assert((words_string(\"The quick brown fox jumps over the lazy dog, and then it ran away\") == std::vector<std::string>{\"The\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\", \"the\", \"lazy\", \"dog\", \"and\", \"then\", \"it\", \"ran\", \"away\"}));\n    assert((words_string(\"The quick brown fox jumps over the lazy dog, and then it ran away, but the cat caught it\") == std::"}
{"task_id": "HumanEval_18_how_many_times", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n\n    long count = 0;\n    for (long i = 0; i < string.length(); i++) {\n        if (string.substr(i, substring.length()) == substring) {\n            count++;\n        }\n    }\n    return count;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    for (long i = 0; i < string.length(); i++) {\n        if (string.substr(i, substring.length()) == substring) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    assert(how_many_times(\"\", \"a\") == 0);\n    assert(how_many_times(\"aaa\", \"a\") == 3);\n    assert(how_many_times(\"aaaa\", \"aa\") == 3);\n    std::cout << \"Passed!\" << std::endl;\n}"}
{"task_id": "HumanEval_137_compare_one", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n\n    if (a == b) {\n        return std::nullopt;\n    } else if (a == b.f0) {\n        return a.f0;\n    } else if (a == b.f1) {\n        return b.f1;\n    } else if (a == b.f2) {\n        return b.f2;\n    } else {\n        return a.f2;\n    }", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    } else if (a == b.f0) {\n        return a.f0;\n    } else if (a == b.f1) {\n        return b.f1;\n    } else if (a == b.f2) {\n        return b.f2;\n    } else {\n        return a.f2;\n    }\n}\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns either the maximum or minimum value depending on the\n// input arguments.\n// All inputs are valid\n// If the arguments are equal, return None\n// >>> compare_two(1, 2.5f, \"Max\")\n// 2.5f\n// >>> compare_two(1, \"2,3\", \"Max\")\n// \"2,3\"\n// >>> compare_two(\"5,1\", \"6\", \"Min\")\n// \"5,1\"\n// >>> compare_two(1, 1, \"Max\")\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_two(Union_long_float_std_string a, Union_long_float_std_string b, std::string c) {\n    if (a == b) {\n        return std::nullopt;\n    } else if (a == b.f0) {\n        return c == \"Max\" ? a.f0 : b.f0;\n    } else if (a == b.f1) {\n        return c == \"Max\" ? a.f1 : b.f1;\n    } else if (a == b.f2) {\n        return c == \"Max\" ? a.f2 : b.f2;\n    } else {\n        return c == \"Max\" ? b.f2 : a.f2;\n    }\n}\n// Create a function that takes a list of integers, floats, or strings\n// representing real numbers, and returns the sum of the list values.\n// >>> sum_list([1, 2, 3, 4])\n// 10\n// >>> sum_list([1, \"2,3\", 3])\n// 6.3f\n// >>> sum_list([1, 2, \"3,4\"])\n// 6.4f\nfloat sum_list(std::vector<Union_long_float_std_string> a) {\n    float sum = 0;\n    for (auto i : a) {\n"}
{"task_id": "HumanEval_51_remove_vowels", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result = \"\";\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result = \"\";\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert(remove_vowels(\"\") == \"\");\n    assert(remove_vowels(\"abcdef\") == \"bcdf\");\n    assert(remove_vowels(\"aaaaa\") == \"\");\n    assert(remove_vowels(\"aaBAA\") == \"B\");\n    assert(remove_vowels(\"zbcd\") == \"zbcd\");\n    std::cout << \"All test cases passed!\" << std::endl;\n}"}
{"task_id": "HumanEval_70_strange_sort_list", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n\n    std::vector<long> result;\n    std::sort(lst.begin(), lst.end());\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    std::sort(lst.begin(), lst.end());\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert((strange_sort_list(std::vector<long>({1, 2, 3, 4})) == std::vector<long>({1, 4, 2, 3})));\n    assert((strange_sort_list(std::vector<long>({5, 5, 5, 5})) == std::vector<long>({5, 5, 5, 5})));\n    assert((strange_sort_list(std::vector<long>({})) == std::vector<long>({})));\n    std::cout << \"All cases passed\" << std::endl;\n}"}
{"task_id": "HumanEval_20_find_closest_elements", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n\n    assert(numbers.size() >= 2);\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    float first = 0.0f;\n    float second = 0.0f;\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        if (numbers[i + 1] - numbers[i] < min_diff) {\n            min_diff = numbers[i + 1] - numbers[i];\n            first = numbers[i];\n            second = numbers[i + 1];\n        }\n    }\n    return std::make_tuple(first, second);", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    float first = 0.0f;\n    float second = 0.0f;\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        if (numbers[i + 1] - numbers[i] < min_diff) {\n            min_diff = numbers[i + 1] - numbers[i];\n            first = numbers[i];\n            second = numbers[i + 1];\n        }\n    }\n    return std::make_tuple(first, second);\n}\n\nint main() {\n    assert(std::get<0>(find_closest_elements(std::vector<float>({1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.2f}))) == 2.0f);\n    assert(std::get<1>(find_closest_elements(std::vector<float>({1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.2f}))) == 2.2f);\n    assert(std::get<0>(find_closest_elements(std::vector<float>({1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.0f}))) == 2.0f);\n    assert(std::get<1>(find_closest_elements(std::vector<float>({1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.0f}))) == 2.0f);\n    std::cout << \"All test cases passed successfully!\" << std::endl;\n}"}
{"task_id": "HumanEval_76_is_simple_power", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n\n    if (x == 1) return true;\n    if (n == 1) return false;\n    long long power = n;\n    while (power < x) {\n        power *= n;\n    }\n    return power == x;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if (x == 1) return true;\n    if (n == 1) return false;\n    long long power = n;\n    while (power < x) {\n        power *= n;\n    }\n    return power == x;\n}\nint main() {\n    assert(is_simple_power(1, 4) == true);\n    assert(is_simple_power(2, 2) == true);\n    assert(is_simple_power(8, 2) == true);\n    assert(is_simple_power(3, 2) == false);\n    assert(is_simple_power(3, 1) == false);\n    assert(is_simple_power(5, 3) == false);\n    return 0;\n}"}
{"task_id": "HumanEval_39_prime_fib", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n\n    long a = 0, b = 1, c = 0, i = 0;\n    while (i < n) {\n        c = a + b;\n        a = b;\n        b = c;\n        if (c % 2 == 1) {\n            for (long j = 3; j <= sqrt(c); j += 2) {\n                if (c % j == 0) {\n                    break;\n                }\n                if (j == sqrt(c)) {\n                    i++;\n                }\n            }\n        }\n    }\n    return c;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long a = 0, b = 1, c = 0, i = 0;\n    while (i < n) {\n        c = a + b;\n        a = b;\n        b = c;\n        if (c % 2 == 1) {\n            for (long j = 3; j <= sqrt(c); j += 2) {\n                if (c % j == 0) {\n                    break;\n                }\n                if (j == sqrt(c)) {\n                    i++;\n                }\n            }\n        }\n    }\n    return c;\n}"}
{"task_id": "HumanEval_145_order_by_points", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n\n    std::vector<long> res;\n    std::map<int, std::vector<long>> m;\n    for (int i = 0; i < nums.size(); i++) {\n        int sum = 0;\n        long num = nums[i];\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        m[sum].push_back(nums[i]);\n    }\n    for (auto it = m.begin(); it != m.end(); it++) {\n        for (int i = 0; i < it->second.size(); i++) {\n            res.push_back(it->second[i]);\n        }\n    }\n    return res;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<long> res;\n    std::map<int, std::vector<long>> m;\n    for (int i = 0; i < nums.size(); i++) {\n        int sum = 0;\n        long num = nums[i];\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        m[sum].push_back(nums[i]);\n    }\n    for (auto it = m.begin(); it != m.end(); it++) {\n        for (int i = 0; i < it->second.size(); i++) {\n            res.push_back(it->second[i]);\n        }\n    }\n    return res;\n}\n\nint main() {\n    assert((order_by_points(std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})) == std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));\n    assert((order_by_points(std::vector<long>()) == std::vector<long>()));\n    assert((order_by_points(std::vector<long>({(long)10, (long)100, (long)1000, (long)10000})) == std::vector<long>({(long)10, (long)100, (long)1000, (long)10000})));\n    assert((order_by_points(std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})) == std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})));\n    assert((order_by_points(std::vector<long>({(long)11, (long)12, (long)13, (long)14, (long)15})) == std::vector<long>({(long)11, (long)12, (long)13, (long)14, (long)15})));\n    assert((order_by_points(std::vector<long>({(long)111, (long)112, (long)113, (long)"}
{"task_id": "HumanEval_0_has_close_elements", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n\n    std::sort(numbers.begin(), numbers.end());\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n    return false;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    assert(has_close_elements(std::vector<float>({1.0f, 2.0f, 3.0f}), 0.5f) == false);\n    assert(has_close_elements(std::vector<float>({1.0f, 2.8f, 3.0f, 4.0f, 5.0f, 2.0f}), 0.3f) == true);\n    std::cout << \"All test cases passed successfully!\" << std::endl;\n}"}
{"task_id": "HumanEval_10_make_palindrome", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n\n    int n = string.size();\n    std::vector<int> z(n, 0);\n    for (int i = 1, l = 0, r = 0; i < n; ++i) {\n        if (i <= r) {\n            z[i] = std::min(r - i + 1, z[i - l]);\n        }\n        while (i + z[i] < n && string[z[i]] == string[i + z[i]]) {\n            ++z[i];\n        }\n        if (i + z[i] - 1 > r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    int i = n - 1;\n    while (i >= 0 && z[i] != i + 1) {\n        --i;\n    }\n    return string + std::string(string.rbegin(), string.rbegin() + i);", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::vector<int> z(n, 0);\n    for (int i = 1, l = 0, r = 0; i < n; ++i) {\n        if (i <= r) {\n            z[i] = std::min(r - i + 1, z[i - l]);\n        }\n        while (i + z[i] < n && string[z[i]] == string[i + z[i]]) {\n            ++z[i];\n        }\n        if (i + z[i] - 1 > r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    int i = n - 1;\n    while (i >= 0 && z[i] != i + 1) {\n        --i;\n    }\n    return string + std::string(string.rbegin(), string.rbegin() + i);\n}\nint main() {\n    assert(make_palindrome(\"\") == \"\");\n    assert(make_palindrome(\"cat\") == \"catac\");\n    assert(make_palindrome(\"cata\") == \"catac\");\n    return 0;\n}"}
{"task_id": "HumanEval_11_string_xor", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n\n    std::string result;\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert(string_xor(\"010\", \"110\") == \"100\");\n    assert(string_xor(\"0101010101\", \"1101010101\") == \"1000000000\");\n    assert(string_xor(\"1111111111\", \"1111111111\") == \"0000000000\");\n    assert(string_xor(\"0000000000\", \"1111111111\") == \"1111111111\");\n    assert(string_xor(\"1010101010\", \"0101010101\") == \"1111111111\");\n    assert(string_xor(\"1111111111\", \"0000000000\") == \"1111111111\");\n    assert(string_xor(\"0000000000\", \"0000000000\") == \"0000000000\");\n    assert(string_xor(\"1111111111\", \"1111111111\") == \"0000000000\");\n    assert(string_xor(\"0000000000\", \"1111111111\") == \"1111111111\");\n    assert(string_xor(\"1111111111\", \"0000000000\") == \"1111111111\");\n    assert(string_xor(\"0000000000\", \"0000000000\") == \"0000000000\");\n    assert(string_xor(\"11"}
{"task_id": "HumanEval_139_special_factorial", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n\n    long long res = 1;\n    for (long i = 1; i <= n; i++) {\n        for (long j = 1; j <= i; j++) {\n            res *= j;\n        }\n    }\n    return res;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long long res = 1;\n    for (long i = 1; i <= n; i++) {\n        for (long j = 1; j <= i; j++) {\n            res *= j;\n        }\n    }\n    return res;\n}\n\nint main() {\n    assert(special_factorial(4) == 288);\n    assert(special_factorial(5) == 34560);\n    assert(special_factorial(6) == 24883200);\n    assert(special_factorial(7) == 2903040000);\n    assert(special_factorial(8) == 465376000000);\n    assert(special_factorial(9) == 102060480000000);\n    assert(special_factorial(10) == 39916800000000000);\n    assert(special_factorial(11) == 2174131200000000000);\n    assert(special_factorial(12) == 162259200000000000000);\n    assert(special_factorial(13) == 18579456000000000000000);\n    assert(special_factorial(14) == 3048883200000000000000000);\n    assert(special_factorial(15) == 725760000000000000000000000);\n    assert(special_factorial(16) == 209865792000000000000000000000);\n    assert(special_factorial(17) == 74364224000000000000000000000000);\n    assert(special_factorial(18) == 3048883"}
{"task_id": "HumanEval_122_add_elements", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n\n    long sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= 0 && arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    return sum;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n    long sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= 0 && arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    assert(add_elements(std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9}), (4)) == 24);\n    assert(add_elements(std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9}), (2)) == 22);\n    assert(add_elements(std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9}), (1)) == 111);\n    assert(add_elements(std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9}), (0)) == 0);\n    assert(add_elements(std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9}), (9)) == 120);\n    assert(add_elements(std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9}), (8)) == 117);\n    assert(add_elements(std::vector<long>({(long)111, (long)21, (long)3, ("}
{"task_id": "HumanEval_46_fib4", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n\n    if (n == 0 || n == 1) {\n        return 0;\n    } else if (n == 2) {\n        return 2;\n    } else if (n == 3) {\n        return 0;\n    } else {\n        long a = 0, b = 0, c = 2, d = 0;\n        for (long i = 4; i <= n; i++) {\n            long temp = a + b + c + d;\n            a = b;\n            b = c;\n            c = d;\n            d = temp;\n        }\n        return d;\n    }", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n == 0 || n == 1) {\n        return 0;\n    } else if (n == 2) {\n        return 2;\n    } else if (n == 3) {\n        return 0;\n    } else {\n        long a = 0, b = 0, c = 2, d = 0;\n        for (long i = 4; i <= n; i++) {\n            long temp = a + b + c + d;\n            a = b;\n            b = c;\n            c = d;\n            d = temp;\n        }\n        return d;\n    }\n}\n\nint main() {\n    assert(fib4(5) == 4);\n    assert(fib4(6) == 8);\n    assert(fib4(7) == 14);\n    assert(fib4(8) == 28);\n    assert(fib4(9) == 52);\n    assert(fib4(10) == 96);\n    assert(fib4(11) == 178);\n    assert(fib4(12) == 334);\n    assert(fib4(13) == 626);\n    assert(fib4(14) == 1170);\n    assert(fib4(15) == 2188);\n    assert(fib4(16) == 4076);\n    assert(fib4(17) == 7626);\n    assert(fib4(18) == 14324);\n    assert(fib4(19) == 26618);\n    assert(fib4(20) == 49346);\n    assert(fib4(21) == 92082);\n    assert(fib4(22) == 170702);\n    assert(fib4(23) == 315230);\n    assert(fib4(24) == 585284);\n    assert(fib4(25) == 1081346);\n    assert(fib4(26) == 2015926);\n    assert(fib4(27) == 37660"}
{"task_id": "HumanEval_104_unique_digits", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n\n    std::vector<long> result;\n    for (auto i : x) {\n        bool has_even_digit = false;\n        for (auto j : std::to_string(i)) {\n            if ((j - '0') % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (auto i : x) {\n        bool has_even_digit = false;\n        for (auto j : std::to_string(i)) {\n            if ((j - '0') % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;\n}\nint main() {\n    assert((unique_digits(std::vector<long>({(long)15, (long)33, (long)1422, (long)1})) == std::vector<long>({(long)1, (long)15, (long)33})));\n    assert((unique_digits(std::vector<long>({(long)152, (long)323, (long)1422, (long)10})) == std::vector<long>()));\n    std::cout << \"Pass test cases!\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_117_select_words", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n\n    std::vector<std::string> result;\n    std::string word;\n    for (char c : s) {\n        if (c == ' ') {\n            if (count_consonants(word) == n) {\n                result.push_back(word);\n            }\n            word = \"\";\n        } else {\n            word += c;\n        }\n    }\n    if (count_consonants(word) == n) {\n        result.push_back(word);\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::string word;\n    for (char c : s) {\n        if (c == ' ') {\n            if (count_consonants(word) == n) {\n                result.push_back(word);\n            }\n            word = \"\";\n        } else {\n            word += c;\n        }\n    }\n    if (count_consonants(word) == n) {\n        result.push_back(word);\n    }\n    return result;\n}\n\nlong count_consonants(std::string s) {\n    long count = 0;\n    for (char c : s) {\n        if (is_consonant(c)) {\n            count++;\n        }\n    }\n    return count;\n}\n\nbool is_consonant(char c) {\n    return isalpha(c) && !is_vowel(c);\n}\n\nbool is_vowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nint main() {\n    assert(select_words((\"Mary had a little lamb\"), (4)) == std::vector<std::string>({(std::string)\"little\"}));\n    assert(select_words((\"Mary had a little lamb\"), (3)) == std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}));\n    assert(select_words((\"simple white space\"), (2)) == std::vector<std::string>());\n    assert(select_words((\"Hello world\"), (4)) == std::vector<std::string>({(std::string)\"world\"}));\n    assert(select_words((\"Uncle sam\"), (3)) == std::vector<std::string>({(std::string)\"Uncle\"}));\n    return 0;\n}"}
{"task_id": "HumanEval_72_will_it_fly", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum > w) {\n        return false;\n    }\n    for (long i = 0; i < q.size() / 2; i++) {\n        if (q[i] != q[q.size() - i - 1]) {\n            return false;\n        }\n    }\n    return true;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum > w) {\n        return false;\n    }\n    for (long i = 0; i < q.size() / 2; i++) {\n        if (q[i] != q[q.size() - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    assert(will_it_fly(std::vector<long>({(long)1, (long)2}), (5)) == false);\n    assert(will_it_fly(std::vector<long>({(long)3, (long)2, (long)3}), (1)) == false);\n    assert(will_it_fly(std::vector<long>({(long)3, (long)2, (long)3}), (9)) == true);\n    assert(will_it_fly(std::vector<long>({(long)3}), (5)) == true);\n    std::cout << \"All tests passed.\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_55_fib", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n\n    if (n <= 1) return n;\n    return fib(n - 1) + fib(n - 2);", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1) return n;\n    return fib(n - 1) + fib(n - 2);\n}\n\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1) return n;\n    return fib(n - 1) + fib(n - 2);\n}\n\nint main() {\n    assert(fib(10) == 55);\n    assert(fib(1) == 1);\n    assert(fib(8) == 21);\n    std::cout << \"tests passed\" << std::endl;\n}"}
{"task_id": "HumanEval_153_Strongest_Extension", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n\n    int max_strength = INT_MIN;\n    std::string strongest_extension;\n    for (const auto& extension : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : extension) {\n            if (isupper(c)) {\n                cap++;\n            } else if (islower(c)) {\n                sm++;\n            }\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    return class_name + \".\" + strongest_extension;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n    std::string strongest_extension;\n    for (const auto& extension : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : extension) {\n            if (isupper(c)) {\n                cap++;\n            } else if (islower(c)) {\n                sm++;\n            }\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\nint main() {\n    assert(Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) == \"my_class.AA\");\n    assert(Strongest_Extension(\"Slices\", {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"}) == \"Slices.SErviNGSliCes\");\n    assert(Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) == \"my_class.AA\");\n    assert(Strongest_Extension(\"Class\", {\"Me\", \"met\", \"mett\"}) == \"Class.Me\");\n    assert(Strongest_Extension(\"Class\", {\"Met\", \"met\", \"mett\"}) == \"Class.Met\");\n    assert(Strongest_Extension(\"Class\", {\"Met\", \"met\", \"Met\"}) == \"Class.Met\");\n    assert(Strongest_Extension(\"Class\", {\"Met\", \"met\", \"Met\"}) == \"Class.Met\");\n    assert(Strongest_Extension(\"Class\", {\"Met\", \"met\", \"Met\"}) == \"Class.Met\");\n    assert(Strongest_Extension(\"Class\", {\"Met\", \"met\", \"Met\"}) == \"Class.Met\");\n    assert(Strongest_Extension(\"Class\", {\"Met\", \"met\", \"Met\"}) == \"Class.Met\");\n    assert(Strongest_Extension(\"Class\", {\"Met\", \"met\", \"Met\"}) == \"Class.Met\");\n    assert(Strongest_Extension(\"Class\", {\"Met\", \"met\", \"Met\"}) == \"Class.Met\");\n    assert(Strongest_Extension(\"Class\", {\"Met\", \"met\", \"Met\"}) == \"Class.Met\");\n    assert(Strongest_Extension(\"Class\", {\"Met\", \"met\", \"Met\"}) == \"Class.Met\");\n    assert("}
{"task_id": "HumanEval_119_match_parens", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n\n    int open = 0, close = 0;\n    for (auto s : lst) {\n        for (auto c : s) {\n            if (c == '(') {\n                open++;\n            } else {\n                close++;\n            }\n        }\n    }\n    if (open == close) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n    int open = 0, close = 0;\n    for (auto s : lst) {\n        for (auto c : s) {\n            if (c == '(') {\n                open++;\n            } else {\n                close++;\n            }\n        }\n    }\n    if (open == close) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nint main() {\n    assert(match_parens(std::vector<std::string>{\"()(\", \")\"} ) == \"Yes\");\n    assert(match_parens(std::vector<std::string>{\")\", \")\"} ) == \"No\");\n    assert(match_parens(std::vector<std::string>{\"(\", \")\"} ) == \"Yes\");\n    assert(match_parens(std::vector<std::string>{\")(\", \"(\"} ) == \"Yes\");\n    assert(match_parens(std::vector<std::string>{\"(()\", \"())\"} ) == \"Yes\");\n    assert(match_parens(std::vector<std::string>{\"(\", \"(\"} ) == \"No\");\n    assert(match_parens(std::vector<std::string>{\")\", \"(\"} ) == \"No\");\n    assert(match_parens(std::vector<std::string>{\"(\", \")}{(\"} ) == \"No\");\n    std::cout << \"All cases passed\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_90_next_smallest", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n    std::sort(lst.begin(), lst.end());\n    return lst[1];", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n    std::sort(lst.begin(), lst.end());\n    return lst[1];\n}\n\nint main() {\n    assert(next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert(next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert(next_smallest({}) == std::nullopt);\n    assert(next_smallest({1, 1}) == std::nullopt);\n    return 0;\n}"}
{"task_id": "HumanEval_92_any_int", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n\n    if (x == y + z || y == x + z || z == x + y) {\n        return true;\n    } else {\n        return false;\n    }", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    if (x == y + z || y == x + z || z == x + y) {\n        return true;\n    } else {\n        return false;\n    }\n}\nint main() {\n    assert(any_int(5, 2, 7) == true);\n    assert(any_int(3, 2, 2) == false);\n    assert(any_int(3, -2, 1) == true);\n    assert(any_int(3.6f, -2.2f, 2) == false);\n    return 0;\n}"}
{"task_id": "HumanEval_2_truncate_number", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n\n    return number - (int)number;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    return number - (int)number;\n}\n\nint main() {\n    assert(truncate_number(3.5f) == 0.5f);\n    assert(truncate_number(1.2f) == 0.2f);\n    assert(truncate_number(0.0f) == 0.0f);\n    assert(truncate_number(1.0f) == 0.0f);\n    assert(truncate_number(1.9f) == 0.9f);\n    assert(truncate_number(1.999999f) == 0.999999f);\n    assert(truncate_number(12.999999f) == 0.999999f);\n    assert(truncate_number(12.0f) == 0.0f);\n    assert(truncate_number(12.0000001f) == 0.0000001f);\n    std::cout << \"All test cases passed successfully!\" << std::endl;\n}"}
{"task_id": "HumanEval_42_incr_list", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n\n    for (int i = 0; i < l.size(); i++) {\n        l[i] += 1;\n    }\n    return l;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    for (int i = 0; i < l.size(); i++) {\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Return vector with elements decremented by 1.\n// >>> decr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)0, (long)1, (long)2}))\n// >>> decr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)4, (long)2, (long)4, (long)1, (long)2, (long)2, (long)8, (long)-1, (long)122}))\nstd::vector<long> decr_list(std::vector<long> l) {\n    for (int i = 0; i < l.size(); i++) {\n        l[i] -= 1;\n    }\n    return l;\n}\n\n// Return vector with elements doubled.\n// >>> double_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)4, (long)6}))\n// >>> double_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)10, (long)6, (long)10, (long)4, (long)6, (long)6, (long)18, (long)0, (long)246}))\nstd::vector<long> double_list(std::vector<long> l) {\n    for (int i = 0; i < l.size(); i++) {\n        l[i] *= 2;\n    }\n    return l;\n}\n\n// Return vector with elements halved.\n// >>> halve_list((std::vector<long>({(long)1, (long)2, ("}
{"task_id": "HumanEval_150_x_or_y", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n\n    // Your code here\n    if(n>1){\n        for(int i=2;i<n;i++){\n            if(n%i==0){\n                return y;\n            }\n        }\n        return x;\n    }\n    return y;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    // Your code here\n    if(n>1){\n        for(int i=2;i<n;i++){\n            if(n%i==0){\n                return y;\n            }\n        }\n        return x;\n    }\n    return y;\n}\n\nint main() {\n    assert((x_or_y(7, 34, 12) == 34));\n    assert((x_or_y(15, 8, 5) == 5));\n    std::cout<<\"Correct\";\n}"}
{"task_id": "HumanEval_49_modp", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n\n    long res = 1;\n    while (n > 0) {\n        if (n & 1) res = (res * p) % p;\n        p = (p * p) % p;\n        n >>= 1;\n    }\n    return res;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    long res = 1;\n    while (n > 0) {\n        if (n & 1) res = (res * p) % p;\n        p = (p * p) % p;\n        n >>= 1;\n    }\n    return res;\n}\n\n// Return n! modulo p (be aware of numerics).\n// >>> modfact(5, 11)\n// (10)\n// >>> modfact(0, 11)\n// (1)\n// >>> modfact(6, 11)\n// (1)\n// >>> modfact(10, 11)\n// (10)\nlong modfact(long n, long p) {\n    long res = 1;\n    for (long i = 2; i <= n; i++) res = (res * i) % p;\n    return res;\n}\n\n// Return n! modulo p (be aware of numerics).\n// >>> modfact(5, 11)\n// (10)\n// >>> modfact(0, 11)\n// (1)\n// >>> modfact(6, 11)\n// (1)\n// >>> modfact(10, 11)\n// (10)\nlong modfact(long n, long p) {\n    long res = 1;\n    for (long i = 2; i <= n; i++) res = (res * i) % p;\n    return res;\n}\n\n// Return n! modulo p (be aware of numerics).\n// >>> modfact(5, 11)\n// (10)\n// >>> modfact(0, 11)\n// (1)\n// >>> modfact(6, 11)\n// (1)\n// >>> modfact(10, 11)\n// (10)\nlong modfact(long n, long p) {\n    long res = 1;\n    for (long i = 2; i <= n; i++) res = (res * i) % p;\n    return res;\n}\n\n// Return n! modulo p (be aware of numerics).\n// >>> modfact(5, 11)\n// (10)\n// >>> modfact(0, 11)\n// (1)\n// >>> modfact(6, 11)\n// (1)\n// >>> modfact(10, 11)\n// ("}
{"task_id": "HumanEval_155_even_odd_count", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n\n    long even = 0, odd = 0;\n    while (num != 0) {\n        if (num % 2 == 0) {\n            even++;\n        } else {\n            odd++;\n        }\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even = 0, odd = 0;\n    while (num != 0) {\n        if (num % 2 == 0) {\n            even++;\n        } else {\n            odd++;\n        }\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);\n}\nint main() {\n    assert(even_odd_count(-12) == std::make_tuple(1, 1));\n    assert(even_odd_count(123) == std::make_tuple(1, 2));\n    assert(even_odd_count(0) == std::make_tuple(1, 0));\n    assert(even_odd_count(111) == std::make_tuple(0, 3));\n    assert(even_odd_count(2468) == std::make_tuple(4, 0));\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_80_is_happy", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n\n    if(s.length() < 3) return false;\n    for(int i = 0; i < s.length() - 2; i++) {\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) return false;\n    }\n    return true;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length() < 3) return false;\n    for(int i = 0; i < s.length() - 2; i++) {\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) return false;\n    }\n    return true;\n}\nint main() {\n    assert(is_happy(\"a\") == false);\n    assert(is_happy(\"aa\") == false);\n    assert(is_happy(\"abcd\") == true);\n    assert(is_happy(\"aabb\") == false);\n    assert(is_happy(\"adb\") == true);\n    assert(is_happy(\"xyy\") == false);\n    std::cout << \"Passed!\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_59_largest_prime_factor", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n\n    long i = 2;\n    while (i * i <= n) {\n        if (n % i) {\n            i += 1;\n        } else {\n            n /= i;\n        }\n    }\n    return n;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    long i = 2;\n    while (i * i <= n) {\n        if (n % i) {\n            i += 1;\n        } else {\n            n /= i;\n        }\n    }\n    return n;\n}\n\nint main() {\n    assert(largest_prime_factor(13195) == 29);\n    assert(largest_prime_factor(2048) == 2);\n    assert(largest_prime_factor(600851475143) == 6857);\n    std::cout << \"All test cases passed successfully.\" << std::endl;\n}"}
{"task_id": "HumanEval_66_digitSum", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n\n    long sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n\nint main() {\n    assert(digitSum(\"\") == 0);\n    assert(digitSum(\"abAB\") == 131);\n    assert(digitSum(\"abcCd\") == 67);\n    assert(digitSum(\"helloE\") == 69);\n    assert(digitSum(\"woArBld\") == 131);\n    assert(digitSum(\"aAaaaXa\") == 153);\n    return 0;\n}"}
{"task_id": "HumanEval_21_rescale_to_unit", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\n    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] < min) {\n            min = numbers[i];\n        }\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n    std::vector<float> rescaled_numbers;\n    for (int i = 0; i < numbers.size(); i++) {\n        rescaled_numbers.push_back((numbers[i] - min) / (max - min));\n    }\n    return rescaled_numbers;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] < min) {\n            min = numbers[i];\n        }\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n    std::vector<float> rescaled_numbers;\n    for (int i = 0; i < numbers.size(); i++) {\n        rescaled_numbers.push_back((numbers[i] - min) / (max - min));\n    }\n    return rescaled_numbers;\n}\n\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<int> numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] < min) {\n            min = numbers[i];\n        }\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n    std::vector<float> rescaled_numbers;\n    for (int i = 0; i < numbers.size(); i++) {\n        rescaled_numbers.push_back((numbers[i] - min) / (max - min));\n    }\n    return rescaled_numbers;\n}\n\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n"}
{"task_id": "HumanEval_121_solution", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    assert(solution(std::vector<long>({(long)5, (long)8, (long)7, (long)1})) == 12);\n    assert(solution(std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})) == 9);\n    assert(solution(std::vector<long>({(long)30, (long)13, (long)24, (long)321})) == 0);\n    std::cout << \"Success\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_68_pluck", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n\n    std::vector<long> result;\n    long min = LONG_MAX;\n    long index = -1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min) {\n            min = arr[i];\n            index = i;\n        }\n    }\n    if (index == -1) {\n        return result;\n    }\n    result.push_back(min);\n    result.push_back(index);\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> result;\n    long min = LONG_MAX;\n    long index = -1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min) {\n            min = arr[i];\n            index = i;\n        }\n    }\n    if (index == -1) {\n        return result;\n    }\n    result.push_back(min);\n    result.push_back(index);\n    return result;\n}\nint main() {\n    assert(pluck(std::vector<long>({(long)4, (long)2, (long)3})) == std::vector<long>({(long)2, (long)1}));\n    assert(pluck(std::vector<long>({(long)1, (long)2, (long)3})) == std::vector<long>({(long)2, (long)1}));\n    assert(pluck(std::vector<long>()) == std::vector<long>());\n    assert(pluck(std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})) == std::vector<long>({(long)0, (long)1}));\n    return 0;\n}"}
{"task_id": "HumanEval_147_get_max_triples", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1  i  n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n\n    long a[n];\n    for (long i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1  i  n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1  i  n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long a[n];\n    for (long i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    assert(get_max_triples(5) == 1);\n    assert(get_max_triples(10) == 16);\n    assert(get_max_triples(15) == 56);\n    assert(get_max_triples(20) == 120);\n    assert(get_max_triples(25) == 220);\n    assert(get_max_triples(30) == 351);\n    assert(get_max_triples(35) == 528);\n    assert(get_max_triples(40) == 750);\n    assert(get_max_triples(45) == 1016);\n    assert(get_max_triples(50) == 1320);\n    assert(get_max_triples(55) == 1661);\n    assert(get_max_triples(60) == 2040);\n    assert(get_max_triples(65) == 2456);\n    assert(get_max_triples(70) == 2910);\n    assert(get_max_triples(75) == 3401);\n    assert(get_max_triples(80) == 3920);\n    assert(get_max_triples(85) == 4476);\n    assert(get_max_triples(90) == 5060);\n    assert(get_max_triples(95) == 5671);\n    assert(get_max_triples(100) == 6310);\n    assert(get_max_triples(105) == 7006);\n    assert(get_max_triples(110) == 7"}
{"task_id": "HumanEval_110_exchange", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n\n    int odd1 = 0, odd2 = 0;\n    for (int i = 0; i < lst1.size(); i++) {\n        if (lst1[i] % 2 != 0) {\n            odd1++;\n        }\n    }\n    for (int i = 0; i < lst2.size(); i++) {\n        if (lst2[i] % 2 != 0) {\n            odd2++;\n        }\n    }\n    if (odd1 <= odd2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    int odd1 = 0, odd2 = 0;\n    for (int i = 0; i < lst1.size(); i++) {\n        if (lst1[i] % 2 != 0) {\n            odd1++;\n        }\n    }\n    for (int i = 0; i < lst2.size(); i++) {\n        if (lst2[i] % 2 != 0) {\n            odd2++;\n        }\n    }\n    if (odd1 <= odd2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\nint main() {\n    assert(exchange(std::vector<long>({(long)1, (long)2, (long)3, (long)4}), std::vector<long>({(long)1, (long)2, (long)3, (long)4})) == \"YES\");\n    assert(exchange(std::vector<long>({(long)1, (long)2, (long)3, (long)4}), std::vector<long>({(long)1, (long)5, (long)3, (long)4})) == \"NO\");\n    assert(exchange(std::vector<long>({(long)1, (long)2, (long)3, (long)4}), std::vector<long>({(long)1, (long)2, (long)3, (long)4})) == \"YES\");\n    assert(exchange(std::vector<long>({(long)1, (long)2, (long)3, (long)4}), std::vector<long>({(long)1, (long)5, (long)3, (long)4})) == \"NO\");\n    assert(exchange(std::vector<long>({(long)1, (long)2, (long)3, (long)4}), std::vector<long>({(long)1, (long)2, (long)3, (long)4})) == \"YES\");\n    assert(exchange(std::vector<long>({(long)1, (long)2, (long)3, (long)4}), std::vector<long>({(long)1, (long)5, (long)3, (long)4})) == \"NO\");\n    assert(exchange(std::vector<long>({(long)1, (long)2, (long)3, ("}
{"task_id": "HumanEval_47_median", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n\n    // Your code goes here\n    sort(l.begin(),l.end());\n    int n=l.size();\n    if(n%2==0)\n    {\n        return (l[n/2]+l[n/2-1])/2.0;\n    }\n    else\n    {\n        return l[n/2];\n    }", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    // Your code goes here\n    sort(l.begin(),l.end());\n    int n=l.size();\n    if(n%2==0)\n    {\n        return (l[n/2]+l[n/2-1])/2.0;\n    }\n    else\n    {\n        return l[n/2];\n    }\n}"}
{"task_id": "HumanEval_82_prime_length", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n\n    int length = string.length();\n    if (length <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    return true;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n    if (length <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    assert(prime_length(\"Hello\") == true);\n    assert(prime_length(\"abcdcba\") == true);\n    assert(prime_length(\"kittens\") == true);\n    assert(prime_length(\"orange\") == false);\n    return 0;\n}"}
{"task_id": "HumanEval_73_smallest_change", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n\n    long changes = 0;\n    int i = 0, j = arr.size() - 1;\n    while (i < j) {\n        if (arr[i] != arr[j]) {\n            changes++;\n        }\n        i++;\n        j--;\n    }\n    return changes;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long changes = 0;\n    int i = 0, j = arr.size() - 1;\n    while (i < j) {\n        if (arr[i] != arr[j]) {\n            changes++;\n        }\n        i++;\n        j--;\n    }\n    return changes;\n}\n\nint main() {\n    assert(smallest_change(std::vector<long>({1, 2, 3, 5, 4, 7, 9, 6})) == 4);\n    assert(smallest_change(std::vector<long>({1, 2, 3, 4, 3, 2, 2})) == 1);\n    assert(smallest_change(std::vector<long>({1, 2, 3, 2, 1})) == 0);\n    std::cout << \"All test cases passed successfully.\" << std::endl;\n}"}
{"task_id": "HumanEval_133_sum_squares", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n\n    long sum = 0;\n    for (float i : lst) {\n        sum += ceil(i) * ceil(i);\n    }\n    return sum;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (float i : lst) {\n        sum += ceil(i) * ceil(i);\n    }\n    return sum;\n}\n\nint main() {\n    assert((sum_squares(std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})) == 14));\n    assert((sum_squares(std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})) == 98));\n    assert((sum_squares(std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})) == 84));\n    assert((sum_squares(std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})) == 29));\n    assert((sum_squares(std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})) == 6));\n    std::cout << \"Success\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_141_file_name_check", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n\n    int dot_count = 0;\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (c == '.') {\n            dot_count++;\n        } else if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n    if (dot_count != 1 || digit_count > 3) {\n        return \"No\";\n    }\n    std::string before_dot = file_name.substr(0, file_name.find('.'));\n    if (before_dot.empty() || !isalpha(before_dot[0])) {\n        return \"No\";\n    }\n    std::string after_dot = file_name.substr(file_name.find('.') + 1);\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") {\n        return \"No\";\n    }\n    return \"Yes\";", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    int dot_count = 0;\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (c == '.') {\n            dot_count++;\n        } else if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n    if (dot_count != 1 || digit_count > 3) {\n        return \"No\";\n    }\n    std::string before_dot = file_name.substr(0, file_name.find('.'));\n    if (before_dot.empty() || !isalpha(before_dot[0])) {\n        return \"No\";\n    }\n    std::string after_dot = file_name.substr(file_name.find('.') + 1);\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n\nint main() {\n    assert(file_name_check(\"example.txt\") == \"Yes\");\n    assert(file_name_check(\"1example.dll\") == \"No\");\n    assert(file_name_check(\"example123.txt\") == \"Yes\");\n    assert(file_name_check(\"example.exe\") == \"Yes\");\n    assert(file_name_check(\"example.dll\") == \"Yes\");\n    assert(file_name_check(\"example.txt123\") == \"No\");\n    assert(file_name_check(\"example.txt.\") == \"No\");\n    assert(file_name_check(\"example.txt1234\") == \"No\");\n    assert(file_name_check(\"example.txt12345\") == \"No\");\n    assert(file_name_check(\"example.txt123456\") == \"No\");\n    assert(file_name_check(\"example.txt1234567\") == \"No\");\n    assert(file_name_check(\"example.txt12345678\") == \"No\");\n    assert(file_name_check(\"example.txt123456789\") == \"No\");\n    assert(file_name_check(\"example.txt1234567890\") == \"No\");\n    assert(file_name_check(\"example.txt12345678901\") == \"No\");\n    assert(file_name_check(\"example.txt123456789012\") == \"No\");\n    assert(file_name_check(\"example.txt1234567890123\") == \"No\");\n    assert(file_name_check(\"example.txt1"}
{"task_id": "HumanEval_40_triples_sum_to_zero", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n\n    // Your code here!\n    return false;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    // Your code here!\n    return false;\n}"}
{"task_id": "HumanEval_127_intersection", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n    }\n    long intersection_start = std::max(start1, start2);\n    long intersection_end = std::min(end1, end2);\n    long intersection_length = intersection_end - intersection_start + 1;\n    if (intersection_length <= 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i * i <= intersection_length; i++) {\n        if (intersection_length % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n    }\n    long intersection_start = std::max(start1, start2);\n    long intersection_end = std::min(end1, end2);\n    long intersection_length = intersection_end - intersection_start + 1;\n    if (intersection_length <= 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i * i <= intersection_length; i++) {\n        if (intersection_length % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}"}
{"task_id": "HumanEval_1_separate_paren_groups", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n\n    std::vector<std::string> result;\n    std::string temp;\n    int count = 0;\n    for (char c : paren_string) {\n        if (c == ' ') {\n            continue;\n        }\n        if (c == '(') {\n            count++;\n        } else if (c == ')') {\n            count--;\n        }\n        temp += c;\n        if (count == 0) {\n            result.push_back(temp);\n            temp = \"\";\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n    int count = 0;\n    for (char c : paren_string) {\n        if (c == ' ') {\n            continue;\n        }\n        if (c == '(') {\n            count++;\n        } else if (c == ')') {\n            count--;\n        }\n        temp += c;\n        if (count == 0) {\n            result.push_back(temp);\n            temp = \"\";\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert((separate_paren_groups(\"() (( )) (( )( ))\") == std::vector<std::string>({std::string(\"()\"), std::string(\"(( ))\"), std::string(\"(( )( ))\")})));\n    assert((separate_paren_groups(\"((()))(())()\") == std::vector<std::string>({std::string(\"((()))\"), std::string(\"(())\"), std::string(\"()\")})));\n    assert((separate_paren_groups(\"()\") == std::vector<std::string>({std::string(\"()\")})));\n    assert((separate_paren_groups(\"((()))\") == std::vector<std::string>({std::string(\"((()))\")})));\n    assert((separate_paren_groups(\"() ()\") == std::vector<std::string>({std::string(\"()\"), std::string(\"()\")})));\n    assert((separate_paren_groups(\"((()))(())()\") == std::vector<std::string>({std::string(\"((()))\"), std::string(\"(())\"), std::string(\"()\")})));\n    assert((separate_paren_groups(\"((()))(())()((()))\") == std::vector<std::string>({std::string(\"((()))\"), std::string(\"(())\"), std::string(\"()\"), std::string(\"((()))\")})));\n    assert((separate_paren_groups(\"((()))(())()((()))(())()\") == std::vector<std::string>({std::string(\"((()))\"), std::string(\"(())\"), std::string(\"()\"), std::string(\"((()))\"), std::string(\"(())\"), std::string(\"()\")})));\n    assert((separate_paren_groups(\"((()))(())()((()))(())()(())\") == std::vector<std::string>({std::string(\"((()))\"), std::string(\"(())\"), std::string(\"()\"), std::string(\"(("}
{"task_id": "HumanEval_152_compare", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n\n    std::vector<long> result;\n    for (int i = 0; i < game.size(); i++) {\n        result.push_back(abs(game[i] - guess[i]));\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    std::vector<long> result;\n    for (int i = 0; i < game.size(); i++) {\n        result.push_back(abs(game[i] - guess[i]));\n    }\n    return result;\n}\n\nint main() {\n    assert((compare(std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1}), std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})) == std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));\n    assert((compare(std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4}), std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})) == std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6})));\n    std::cout << \"All tests passed successfully!\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_83_starts_one_ends", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n\n    assert(n >= 1);\n    if (n == 1) return 1;\n    return 9 * pow(10, n - 2) + starts_one_ends(n - 1);", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    assert(n >= 1);\n    if (n == 1) return 1;\n    return 9 * pow(10, n - 2) + starts_one_ends(n - 1);\n}\n\nint main() {\n    assert(starts_one_ends(1) == 1);\n    assert(starts_one_ends(2) == 19);\n    assert(starts_one_ends(3) == 181);\n    assert(starts_one_ends(4) == 1801);\n    assert(starts_one_ends(5) == 18001);\n    assert(starts_one_ends(6) == 180001);\n    assert(starts_one_ends(7) == 1800001);\n    assert(starts_one_ends(8) == 18000001);\n    assert(starts_one_ends(9) == 180000001);\n    assert(starts_one_ends(10) == 1800000001);\n    assert(starts_one_ends(11) == 18000000001);\n    assert(starts_one_ends(12) == 180000000001);\n    assert(starts_one_ends(13) == 1800000000001);\n    assert(starts_one_ends(14) == 18000000000001);\n    assert(starts_one_ends(15) == 180000000000001);\n    assert(starts_one_ends(16) == 1800000000000001);\n    assert(starts_one_ends(17) == 18000000000000001);\n    assert(starts_one_ends(18) == 180000000000000001);\n    assert(starts_one_ends(19) == 1800000000000000001);\n    assert(starts_one_ends(20) == 180000000000"}
{"task_id": "HumanEval_134_check_if_last_char_is_a_letter", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n\n  if (txt.empty()) return false;\n  if (txt.back() == ' ') return false;\n  if (txt.back() >= 'a' && txt.back() <= 'z') return true;\n  if (txt.back() >= 'A' && txt.back() <= 'Z') return true;\n  return false;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty()) return false;\n  if (txt.back() == ' ') return false;\n  if (txt.back() >= 'a' && txt.back() <= 'z') return true;\n  if (txt.back() >= 'A' && txt.back() <= 'Z') return true;\n  return false;\n}\nint main() {\n  assert(check_if_last_char_is_a_letter(\"apple pi e\") == true);\n  assert(check_if_last_char_is_a_letter(\"apple pi e \") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a\") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a \") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b\") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b \") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b c\") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b c \") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b c d\") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b c d \") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b c d e\") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b c d e \") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b c d e f\") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b c d e f \") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b c d e f g\") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b c d e f g \") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b c d e f g h\") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b c d e f g h \") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b c d e f g h i\") == false);\n  assert(check_if_last_char_is_a_letter(\"apple pi e a b c d e f g h i \") =="}
{"task_id": "HumanEval_124_valid_date", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n\n    std::string month, day, year;\n    std::stringstream ss(date);\n    std::getline(ss, month, '-');\n    std::getline(ss, day, '-');\n    std::getline(ss, year, '-');\n    if (month.length() != 2 || day.length() != 2 || year.length() != 4) {\n        return false;\n    }\n    int m = std::stoi(month);\n    int d = std::stoi(day);\n    int y = std::stoi(year);\n    if (m < 1 || m > 12 || d < 1 || d > 31 || y < 1) {\n        return false;\n    }\n    if (m == 2) {\n        if (d > 29) {\n            return false;\n        }\n        if (d == 29) {\n            if (y % 4 != 0 || (y % 100 == 0 && y % 400 != 0)) {\n                return false;\n            }\n        }\n    } else if (m == 4 || m == 6 || m == 9 || m == 11) {\n        if (d > 30) {\n            return false;\n        }\n    }\n    return true;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    std::string month, day, year;\n    std::stringstream ss(date);\n    std::getline(ss, month, '-');\n    std::getline(ss, day, '-');\n    std::getline(ss, year, '-');\n    if (month.length() != 2 || day.length() != 2 || year.length() != 4) {\n        return false;\n    }\n    int m = std::stoi(month);\n    int d = std::stoi(day);\n    int y = std::stoi(year);\n    if (m < 1 || m > 12 || d < 1 || d > 31 || y < 1) {\n        return false;\n    }\n    if (m == 2) {\n        if (d > 29) {\n            return false;\n        }\n        if (d == 29) {\n            if (y % 4 != 0 || (y % 100 == 0 && y % 400 != 0)) {\n                return false;\n            }\n        }\n    } else if (m == 4 || m == 6 || m == 9 || m == 11) {\n        if (d > 30) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    assert(valid_date(\"03-11-2000\") == true);\n    assert(valid_date(\"15-01-2012\") == false);\n    assert(valid_date(\"04-0-2040\") == false);\n    assert(valid_date(\"06-04-2020\") == true);\n    assert(valid_date(\"06/04/2020\") == false);\n    std::cout << \"All test cases passed successfully.\" << std::endl;\n}"}
{"task_id": "HumanEval_108_count_nums", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n\n    long count = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        long sum = 0;\n        long num = arr[i];\n        if (num < 0) {\n            num = -num;\n        }\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        long sum = 0;\n        long num = arr[i];\n        if (num < 0) {\n            num = -num;\n        }\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    assert(count_nums(std::vector<long>()) == 0);\n    assert(count_nums(std::vector<long>({(long)-1, (long)11, (long)-11})) == 1);\n    assert(count_nums(std::vector<long>({(long)1, (long)1, (long)2})) == 3);\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_86_anti_shuffle", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n\n    std::string result;\n    std::string word;\n    for (char c : s) {\n        if (c == ' ') {\n            std::sort(word.begin(), word.end());\n            result += word + ' ';\n            word.clear();\n        } else {\n            word += c;\n        }\n    }\n    std::sort(word.begin(), word.end());\n    result += word;\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::string result;\n    std::string word;\n    for (char c : s) {\n        if (c == ' ') {\n            std::sort(word.begin(), word.end());\n            result += word + ' ';\n            word.clear();\n        } else {\n            word += c;\n        }\n    }\n    std::sort(word.begin(), word.end());\n    result += word;\n    return result;\n}\nint main() {\n    assert(anti_shuffle(\"Hi\") == \"Hi\");\n    assert(anti_shuffle(\"hello\") == \"ehllo\");\n    assert(anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\");\n    return 0;\n}"}
{"task_id": "HumanEval_48_is_palindrome", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n\n    int n = text.length();\n    for (int i = 0; i < n / 2; i++) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n    int n = text.length();\n    for (int i = 0; i < n / 2; i++) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n    int n = text.length();\n    for (int i = 0; i < n / 2; i++) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n    int n = text.length();\n    for (int i = 0; i < n / 2; i++) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n    int n = text.length();\n    for (int i = 0; i < n / 2; i++) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n    int n = text.length();\n   "}
{"task_id": "HumanEval_118_get_closest_vowel", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (i > 0 && consonants.find(word[i - 1]) != std::string::npos && i < word.length() - 1 && consonants.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result = \"\";\n    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (i > 0 && consonants.find(word[i - 1]) != std::string::npos && i < word.length() - 1 && consonants.find(word[i + 1]) != std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    assert(get_closest_vowel(\"yogurt\") == \"u\");\n    assert(get_closest_vowel(\"FULL\") == \"U\");\n    assert(get_closest_vowel(\"quick\") == \"\");\n    assert(get_closest_vowel(\"ab\") == \"\");\n    return 0;\n}"}
{"task_id": "HumanEval_31_is_prime", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    assert(is_prime(6) == false);\n    assert(is_prime(101) == true);\n    assert(is_prime(11) == true);\n    assert(is_prime(13441) == true);\n    assert(is_prime(61) == true);\n    assert(is_prime(4) == false);\n    assert(is_prime(1) == false);\n    std::cout << \"All test cases passed!\" << std::endl;\n}"}
{"task_id": "HumanEval_144_simplify", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n\n    int x_num = std::stoi(x.substr(0, x.find('/')));\n    int x_den = std::stoi(x.substr(x.find('/') + 1));\n    int n_num = std::stoi(n.substr(0, n.find('/')));\n    int n_den = std::stoi(n.substr(n.find('/') + 1));\n    int num = x_num * n_num;\n    int den = x_den * n_den;\n    int gcd = std::gcd(num, den);\n    num /= gcd;\n    den /= gcd;\n    return den == 1;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    int x_num = std::stoi(x.substr(0, x.find('/')));\n    int x_den = std::stoi(x.substr(x.find('/') + 1));\n    int n_num = std::stoi(n.substr(0, n.find('/')));\n    int n_den = std::stoi(n.substr(n.find('/') + 1));\n    int num = x_num * n_num;\n    int den = x_den * n_den;\n    int gcd = std::gcd(num, den);\n    num /= gcd;\n    den /= gcd;\n    return den == 1;\n}\n\nint main() {\n    assert(simplify(\"1/5\", \"5/1\") == true);\n    assert(simplify(\"1/6\", \"2/1\") == false);\n    assert(simplify(\"7/10\", \"10/2\") == false);\n    assert(simplify(\"1/3\", \"3/1\") == true);\n    assert(simplify(\"2/4\", \"4/2\") == true);\n    assert(simplify(\"5/7\", \"7/5\") == false);\n    assert(simplify(\"1/2\", \"2/1\") == true);\n    assert(simplify(\"3/4\", \"4/3\") == true);\n    assert(simplify(\"1/2\", \"3/4\") == false);\n    assert(simplify(\"2/3\", \"3/2\") == true);\n    assert(simplify(\"1/2\", \"4/8\") == true);\n    assert(simplify(\"1/2\", \"3/6\") == true);\n    assert(simplify(\"1/2\", \"5/10\") == true);\n    assert(simplify(\"1/2\", \"7/14\") == true);\n    assert(simplify(\"1/2\", \"9/18\") == true);\n    assert(simplify(\"1/2\", \"11/22\") == true);\n    assert(simplify(\"1/2\", \"13/26\") == true);\n    assert(simplify(\"1/2\", \"15/30\") == true);\n    assert(simplify(\"1/2\", \"17/34\") == true);\n    assert(simplify(\"1/2\", \"19/38\") == true);\n    assert(simplify(\"1/2\", \"21/42\") == true);\n    assert(simplify(\""}
{"task_id": "HumanEval_78_hex_key", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\n    long count = 0;\n    for (int i = 0; i < num.length(); i++) {\n        if (num[i] == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' || num[i] == 'B' || num[i] == 'D') {\n            count++;\n        }\n    }\n    return count;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    long count = 0;\n    for (int i = 0; i < num.length(); i++) {\n        if (num[i] == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' || num[i] == 'B' || num[i] == 'D') {\n            count++;\n        }\n    }\n    return count;\n}"}
{"task_id": "HumanEval_143_words_in_sentence", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n\n    std::string result;\n    std::istringstream iss(sentence);\n    std::string word;\n    while (iss >> word) {\n        int len = word.length();\n        bool is_prime = true;\n        if (len <= 1) {\n            is_prime = false;\n        } else {\n            for (int i = 2; i <= sqrt(len); i++) {\n                if (len % i == 0) {\n                    is_prime = false;\n                    break;\n                }\n            }\n        }\n        if (is_prime) {\n            result += word + \" \";\n        }\n    }\n    if (!result.empty()) {\n        result.pop_back();\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::string result;\n    std::istringstream iss(sentence);\n    std::string word;\n    while (iss >> word) {\n        int len = word.length();\n        bool is_prime = true;\n        if (len <= 1) {\n            is_prime = false;\n        } else {\n            for (int i = 2; i <= sqrt(len); i++) {\n                if (len % i == 0) {\n                    is_prime = false;\n                    break;\n                }\n            }\n        }\n        if (is_prime) {\n            result += word + \" \";\n        }\n    }\n    if (!result.empty()) {\n        result.pop_back();\n    }\n    return result;\n}\n\nint main() {\n    assert(words_in_sentence(\"This is a test\") == \"is\");\n    assert(words_in_sentence(\"lets go for swimming\") == \"go for\");\n    assert(words_in_sentence(\"I love programming\") == \"I love\");\n    assert(words_in_sentence(\"The quick brown fox jumps over the lazy dog\") == \"The quick brown fox over the lazy\");\n    assert(words_in_sentence(\"A man a plan a canal Panama\") == \"a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a"}
{"task_id": "HumanEval_111_histogram", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n\n    std::map<std::string,long> result;\n    std::string word;\n    std::stringstream ss(test);\n    while (ss >> word) {\n        result[word]++;\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> result;\n    std::string word;\n    std::stringstream ss(test);\n    while (ss >> word) {\n        result[word]++;\n    }\n    return result;\n}\nint main() {\n    assert(histogram(\"a b c\") == std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}));\n    assert(histogram(\"a b b a\") == std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}));\n    assert(histogram(\"a b c a b\") == std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}));\n    assert(histogram(\"b b b b a\") == std::map<std::string,long>({{\"b\", 4}}));\n    assert(histogram(\"\") == std::map<std::string,long>());\n    std::cout << \"All test cases passed successfully!\" << std::endl;\n}"}
{"task_id": "HumanEval_87_get_row", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n        if (std::get<0>(a) == std::get<0>(b)) {\n            return std::get<1>(a) > std::get<1>(b);\n        }\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n        if (std::get<0>(a) == std::get<0>(b)) {\n            return std::get<1>(a) > std::get<1>(b);\n        }\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    return result;\n}"}
{"task_id": "HumanEval_123_get_odd_collatz", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n\n    std::vector<long> result;\n    result.push_back(n);\n    while(n != 1) {\n        if(n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n        result.push_back(n);\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> result;\n    result.push_back(n);\n    while(n != 1) {\n        if(n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n        result.push_back(n);\n    }\n    std::sort(result.begin(), result.end());\n    return result;\n}\n\nint main() {\n    assert((get_odd_collatz(5) == std::vector<long>({1, 5})));\n    assert((get_odd_collatz(1) == std::vector<long>({1})));\n    assert((get_odd_collatz(10) == std::vector<long>({1, 5, 25})));\n    assert((get_odd_collatz(11) == std::vector<long>({1, 5, 11, 341})));\n    assert((get_odd_collatz(12) == std::vector<long>({1, 3, 5, 15, 45, 135, 405, 1215, 3645, 10935, 32805, 98415, 295245, 885735, 2657205, 7971615, 23914845, 71744535, 215233605, 645690815, 1937072445, 5811217335, 17433651005, 52300953015, 156902859045, 470708577135, 1412125731405, 4236377194215, 12709131582645, 38127394747935, 114382184243805, 3431465"}
{"task_id": "HumanEval_135_can_arrange", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n\n    long max = -1;\n    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < arr[i - 1]) {\n            max = i;\n        }\n    }\n    return max;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long max = -1;\n    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < arr[i - 1]) {\n            max = i;\n        }\n    }\n    return max;\n}\n\nint main() {\n    assert(can_arrange(std::vector<long>({1, 2, 4, 3, 5})) == 3);\n    assert(can_arrange(std::vector<long>({1, 2, 3})) == -1);\n    assert(can_arrange(std::vector<long>({1, 2, 3, 4, 5})) == -1);\n    assert(can_arrange(std::vector<long>({5, 4, 3, 2, 1})) == 4);\n    assert(can_arrange(std::vector<long>({1, 2, 3, 4, 5, 6})) == -1);\n    assert(can_arrange(std::vector<long>({1, 2, 3, 4, 5, 6, 7})) == -1);\n    assert(can_arrange(std::vector<long>({1, 2, 3, 4, 5, 6, 7, 8})) == -1);\n    assert(can_arrange(std::vector<long>({1, 2, 3, 4, 5, 6, 7, 8, 9})) == -1);\n    assert(can_arrange(std::vector<long>({1, 2, 3, 4, 5, 6, 7, 8, 9, 10})) == -1);\n    assert(can_arrange(std::vector<long>({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11})) == -1);\n    assert(can_arrange(std::vector<long>({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12})) == -1);\n    assert(can_arrange(std::vector<long>({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}))"}
{"task_id": "HumanEval_19_sort_numbers", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n\n    std::map<std::string, int> m = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n    std::vector<std::string> v;\n    std::stringstream ss(numbers);\n    std::string word;\n    while (ss >> word) {\n        v.push_back(word);\n    }\n    std::sort(v.begin(), v.end(), [&](std::string a, std::string b) { return m[a] < m[b]; });\n    std::string res;\n    for (auto w : v) {\n        res += w + \" \";\n    }\n    res.pop_back();\n    return res;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::map<std::string, int> m = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n    std::vector<std::string> v;\n    std::stringstream ss(numbers);\n    std::string word;\n    while (ss >> word) {\n        v.push_back(word);\n    }\n    std::sort(v.begin(), v.end(), [&](std::string a, std::string b) { return m[a] < m[b]; });\n    std::string res;\n    for (auto w : v) {\n        res += w + \" \";\n    }\n    res.pop_back();\n    return res;\n}\n\nint main() {\n    assert(sort_numbers(\"three one five\") == \"one three five\");\n    assert(sort_numbers(\"nine eight seven\") == \"seven eight nine\");\n    assert(sort_numbers(\"four two one\") == \"one two four\");\n    assert(sort_numbers(\"six four eight\") == \"four six eight\");\n    assert(sort_numbers(\"five three nine\") == \"three five nine\");\n    assert(sort_numbers(\"seven six five\") == \"five six seven\");\n    assert(sort_numbers(\"two one zero\") == \"zero one two\");\n    assert(sort_numbers(\"eight seven six\") == \"six seven eight\");\n    assert(sort_numbers(\"four three two\") == \"two three four\");\n    assert(sort_numbers(\"nine eight seven\") == \"seven eight nine\");\n    assert(sort_numbers(\"five four three\") == \"three four five\");\n    assert(sort_numbers(\"six five four\") == \"four five six\");\n    assert(sort_numbers(\"two one zero\") == \"zero one two\");\n    assert(sort_numbers(\"eight seven six\") == \"six seven eight\");\n    assert(sort_numbers(\"four three two\") == \"two three four\");\n    assert(sort_numbers(\"nine eight seven\") == \"seven eight nine\");\n    assert(sort_numbers(\"five four three\") == \"three four five\");\n    assert(sort_numbers(\"six five four\") == \"four five six\");\n    assert(sort_numbers(\"two one zero\") == \"zero one two\");\n    assert(sort_numbers(\"eight seven six\") == \"six seven eight\");\n    assert(sort_numbers(\"four three two\") == \"two three four\");\n    assert(sort_numbers"}
{"task_id": "HumanEval_65_circular_shift", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n\n    std::string s = std::to_string(x);\n    int n = s.size();\n    shift %= n;\n    if (shift == 0) {\n        return s;\n    }\n    std::reverse(s.begin(), s.end());\n    std::reverse(s.begin(), s.begin() + shift);\n    std::reverse(s.begin() + shift, s.end());\n    return s;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    int n = s.size();\n    shift %= n;\n    if (shift == 0) {\n        return s;\n    }\n    std::reverse(s.begin(), s.end());\n    std::reverse(s.begin(), s.begin() + shift);\n    std::reverse(s.begin() + shift, s.end());\n    return s;\n}\nint main() {\n    assert(circular_shift(12, 1) == \"21\");\n    assert(circular_shift(12, 2) == \"12\");\n    assert(circular_shift(12345, 4) == \"51234\");\n    assert(circular_shift(12345, 5) == \"12345\");\n    assert(circular_shift(12345, 6) == \"54321\");\n    assert(circular_shift(12345, 7) == \"45123\");\n    assert(circular_shift(12345, 8) == \"34512\");\n    assert(circular_shift(12345, 9) == \"23451\");\n    assert(circular_shift(12345, 10) == \"12345\");\n    assert(circular_shift(12345, 11) == \"54321\");\n    assert(circular_shift(12345, 12) == \"45123\");\n    assert(circular_shift(12345, 13) == \"34512\");\n    assert(circular_shift(12345, 14) == \"23451\");\n    assert(circular_shift(12345, 15) == \"12345\");\n    assert(circular_shift(12345, 16) == \"54321\");\n    assert(circular_shift(12345, 17) == \"45123\");\n    assert(circular_shift(12345, 18) == \"34512\");\n    assert(circular_shift(12345, 19) == \"23451\");\n    assert(circular"}
{"task_id": "HumanEval_142_sum_squares", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    assert(sum_squares({1, 2, 3}) == 14);\n    assert(sum_squares({}) == 0);\n    assert(sum_squares({-1, -5, 2, -1, -5}) == -12);\n    std::cout << \"All tests passed successfully!\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_94_skjkasdkd", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n\n    long max_prime = 0;\n    for (long num : lst) {\n        if (num > max_prime && is_prime(num)) {\n            max_prime = num;\n        }\n    }\n    long sum = 0;\n    while (max_prime > 0) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n    return sum;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long num : lst) {\n        if (num > max_prime && is_prime(num)) {\n            max_prime = num;\n        }\n    }\n    long sum = 0;\n    while (max_prime > 0) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n    return sum;\n}\n\nbool is_prime(long n) {\n    if (n < 2) {\n        return false;\n    }\n    for (long i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    assert(skjkasdkd(std::vector<long>({0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})) == 10);\n    assert(skjkasdkd(std::vector<long>({1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})) == 25);\n    assert(skjkasdkd(std::vector<long>({1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})) == 13);\n    assert(skjkasdkd(std::vector<long>({0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})) == 11);\n    assert(skjkasdkd(std::vector<long>({0, 81, 12, 3, 1, 21})) == 3);\n    assert(sk"}
{"task_id": "HumanEval_8_sum_product", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n\n    long sum = 0;\n    long product = 1;\n    for (long number : numbers) {\n        sum += number;\n        product *= number;\n    }\n    return std::make_tuple(sum, product);", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n    for (long number : numbers) {\n        sum += number;\n        product *= number;\n    }\n    return std::make_tuple(sum, product);\n}\nint main() {\n    assert(std::get<0>(sum_product(std::vector<long>())) == 0);\n    assert(std::get<1>(sum_product(std::vector<long>())) == 1);\n    assert(std::get<0>(sum_product(std::vector<long>({1, 2, 3, 4}))) == 10);\n    assert(std::get<1>(sum_product(std::vector<long>({1, 2, 3, 4}))) == 24);\n    assert(std::get<0>(sum_product(std::vector<long>({1, 2, 3, 4, 5}))) == 15);\n    assert(std::get<1>(sum_product(std::vector<long>({1, 2, 3, 4, 5}))) == 120);\n    assert(std::get<0>(sum_product(std::vector<long>({1, 2, 3, 4, 5, 6}))) == 21);\n    assert(std::get<1>(sum_product(std::vector<long>({1, 2, 3, 4, 5, 6}))) == 720);\n    assert(std::get<0>(sum_product(std::vector<long>({1, 2, 3, 4, 5, 6, 7}))) == 28);\n    assert(std::get<1>(sum_product(std::vector<long>({1, 2, 3, 4, 5, 6, 7}))) == 5040);\n    assert(std::get<0>(sum_product(std::vector<long>({1, 2, 3, 4, 5, 6, 7, 8}))) == 36);\n    assert(std::get<1>(sum_product(std::vector<long>({1, 2, 3, 4, 5, 6, 7, 8}))) == 40320);\n    assert(std::get<0>(sum_product(std::vector<long>({1, 2, 3,"}
{"task_id": "HumanEval_102_choose_num", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n\n    if (x % 2 == 0 && x <= y) {\n        return x;\n    } else if (x % 2 == 1 && x <= y) {\n        return x + 1;\n    } else {\n        return -1;\n    }", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 == 0 && x <= y) {\n        return x;\n    } else if (x % 2 == 1 && x <= y) {\n        return x + 1;\n    } else {\n        return -1;\n    }\n}\n\nint main() {\n    assert(choose_num(12, 15) == 14);\n    assert(choose_num(13, 12) == -1);\n    assert(choose_num(14, 14) == 14);\n    assert(choose_num(15, 15) == -1);\n    assert(choose_num(16, 16) == 16);\n    assert(choose_num(17, 17) == -1);\n    assert(choose_num(18, 18) == 18);\n    assert(choose_num(19, 19) == -1);\n    assert(choose_num(20, 20) == 20);\n    assert(choose_num(21, 21) == -1);\n    assert(choose_num(22, 22) == 22);\n    assert(choose_num(23, 23) == -1);\n    assert(choose_num(24, 24) == 24);\n    assert(choose_num(25, 25) == -1);\n    assert(choose_num(26, 26) == 26);\n    assert(choose_num(27, 27) == -1);\n    assert(choose_num(28, 28) == 28);\n    assert(choose_num(29, 29) == -1);\n    assert(choose_num(30, 30) == 30);\n    assert(choose_num(31, 31) == -1);\n    assert(choose_num(32, 32) == 32);\n    assert(choose_num(33, 33) == -1);\n    assert(choose_num(34, 34) == 34);\n    assert(choose_num(35, 35) == -1);\n    assert(choose_num(36, 36) == 36);\n   "}
{"task_id": "HumanEval_136_largest_smallest_integers", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative.has_value() || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive.has_value() || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n    return std::make_tuple(largest_negative, smallest_positive);", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative.has_value() || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive.has_value() || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n    return std::make_tuple(largest_negative, smallest_positive);\n}\n\nint main() {\n    assert(largest_smallest_integers(std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(largest_smallest_integers(std::vector<long>()) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(largest_smallest_integers(std::vector<long>({(long)0})) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(largest_smallest_integers(std::vector<long>({(long)0, (long)0})) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(largest_smallest_integers(std::vector<long>({(long)0, (long)0, (long)0})) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(largest_smallest_integers(std::vector<long>({(long)0, (long)0, (long)0, (long)0})) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(largest_smallest_integers(std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0})) == std::make_tuple(std::optional<long>(std::nullopt"}
{"task_id": "HumanEval_16_count_distinct_characters", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n\n    std::set<char> s;\n    for (char c : string) {\n        s.insert(tolower(c));\n    }\n    return s.size();", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> s;\n    for (char c : string) {\n        s.insert(tolower(c));\n    }\n    return s.size();\n}\n\n// Given a string, find out how many characters are repeated in it\n// >>> count_repeated_characters((\"abcde\"))\n// (0)\n// >>> count_repeated_characters((\"aabbcde\"))\n// (2)\nlong count_repeated_characters(std::string string) {\n    std::map<char, int> m;\n    for (char c : string) {\n        m[c]++;\n    }\n    long count = 0;\n    for (auto it = m.begin(); it != m.end(); it++) {\n        if (it->second > 1) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Given a string, check if it is a palindrome\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"abba\"))\n// (true)\n// >>> is_palindrome((\"abc\"))\n// (false)\nbool is_palindrome(std::string string) {\n    int i = 0;\n    int j = string.length() - 1;\n    while (i < j) {\n        if (string[i] != string[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n}\n\n// Given a string, find the first non-repeated character in it\n// >>> first_non_repeated_character(\"abcdef\")\n// ('a')\n// >>> first_non_repeated_character(\"abcabcdef\")\n// ('d')\n// >>> first_non_repeated_character(\"aabbcc\")\n// ('\\0')\nchar first_non_repeated_character(std::string string) {\n    std::map<char, int> m;\n    for (char c : string) {\n        m[c]++;\n    }\n    for (char c : string) {\n        if (m[c] == 1) {\n            return c;\n        }\n    }\n    return '\\0';\n}\n\n// Given a string, find the first repeated character in it\n// >>> first_repeated_character(\"abcdef\")\n// ('\\0')\n// >>> first_repeated_character(\"abcabcdef\")\n// ('a')\n// >>> first_repeated_character(\"aabbcc\")\n// ('a')\nchar first_repeated_character(std::string string) {\n    std::map<char, int> m;\n    for (char c : string) {\n        m[c]++;\n    }\n    for (char"}
{"task_id": "HumanEval_100_make_a_pile", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n\n    std::vector<long> result;\n    long current = n;\n    while (n > 0) {\n        result.push_back(current);\n        if (current % 2 == 0) {\n            current += 2;\n        } else {\n            current += 1;\n        }\n        n--;\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> result;\n    long current = n;\n    while (n > 0) {\n        result.push_back(current);\n        if (current % 2 == 0) {\n            current += 2;\n        } else {\n            current += 1;\n        }\n        n--;\n    }\n    return result;\n}\n// Don't edit below this line\n\nvoid test_make_a_pile() {\n    assert(make_a_pile(3) == std::vector<long>({3, 5, 7}));\n    assert(make_a_pile(4) == std::vector<long>({4, 6, 8, 10}));\n    assert(make_a_pile(5) == std::vector<long>({5, 7, 9, 11, 13}));\n    assert(make_a_pile(6) == std::vector<long>({6, 8, 10, 12, 14, 16}));\n    assert(make_a_pile(7) == std::vector<long>({7, 9, 11, 13, 15, 17, 19}));\n    assert(make_a_pile(8) == std::vector<long>({8, 10, 12, 14, 16, 18, 20, 22}));\n    assert(make_a_pile(9) == std::vector<long>({9, 11, 13, 15, 17, 19, 21, 23, 25}));\n    assert(make_a_pile(10) == std::vector<long>({10, 12, 14, 16, 18, 20, 22, 24, 26, 28}));\n    assert(make_a_pile(11) == std::vector<long>({11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31}));\n    assert(make_a_pile(12) == std::vector<long>({12, 14, 16, 18, 20, 22, 24, 26, 2"}
{"task_id": "HumanEval_128_prod_signs", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  long sum = 0;\n  long product = 1;\n  for (long i : arr) {\n    sum += abs(i);\n    if (i > 0) {\n      product *= 1;\n    } else if (i < 0) {\n      product *= -1;\n    } else {\n      product *= 0;\n    }\n  }\n  return sum * product;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  long sum = 0;\n  long product = 1;\n  for (long i : arr) {\n    sum += abs(i);\n    if (i > 0) {\n      product *= 1;\n    } else if (i < 0) {\n      product *= -1;\n    } else {\n      product *= 0;\n    }\n  }\n  return sum * product;\n}\nint main() {\n  assert(prod_signs(std::vector<long>({(long)1, (long)2, (long)2, (long)-4})) == 9);\n  assert(prod_signs(std::vector<long>({(long)0, (long)1})) == 0);\n  assert(prod_signs(std::vector<long>()) == std::nullopt);\n  std::cout << \"All test cases passed!\" << std::endl;\n  return 0;\n}"}
{"task_id": "HumanEval_114_minSubArraySum", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n\n    long min_sum = nums[0];\n    long curr_sum = nums[0];\n    for (int i = 1; i < nums.size(); i++) {\n        curr_sum = std::min(nums[i], curr_sum + nums[i]);\n        min_sum = std::min(min_sum, curr_sum);\n    }\n    return min_sum;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = nums[0];\n    long curr_sum = nums[0];\n    for (int i = 1; i < nums.size(); i++) {\n        curr_sum = std::min(nums[i], curr_sum + nums[i]);\n        min_sum = std::min(min_sum, curr_sum);\n    }\n    return min_sum;\n}\n\nint main() {\n    assert(minSubArraySum(std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})) == 1);\n    assert(minSubArraySum(std::vector<long>({(long)-1, (long)-2, (long)-3})) == -6);\n    std::cout << \"All test cases passed\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_15_string_sequence", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n\n    std::string result;\n    for (long i = 0; i <= n; i++) {\n        result += std::to_string(i) + \" \";\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::string result;\n    for (long i = 0; i <= n; i++) {\n        result += std::to_string(i) + \" \";\n    }\n    return result;\n}\n\nint main() {\n    assert(string_sequence(0) == \"0\");\n    assert(string_sequence(5) == \"0 1 2 3 4 5\");\n    assert(string_sequence(10) == \"0 1 2 3 4 5 6 7 8 9 10\");\n    std::cout << \"All test cases passed successfully.\" << std::endl;\n}"}
{"task_id": "HumanEval_154_cycpattern_check", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n\n    if (a.size() < b.size()) return false;\n    std::string c = b + b;\n    return c.find(a) != std::string::npos;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    if (a.size() < b.size()) return false;\n    std::string c = b + b;\n    return c.find(a) != std::string::npos;\n}\n\nint main() {\n    assert(cycpattern_check(\"abcd\", \"abd\") == false);\n    assert(cycpattern_check(\"hello\", \"ell\") == true);\n    assert(cycpattern_check(\"whassup\", \"psus\") == false);\n    assert(cycpattern_check(\"abab\", \"baa\") == true);\n    assert(cycpattern_check(\"efef\", \"eeff\") == false);\n    assert(cycpattern_check(\"himenss\", \"simen\") == true);\n    std::cout << \"Pass test cases\" << std::endl;\n}"}
{"task_id": "HumanEval_57_monotonic", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n\n    if (l.size() <= 1) {\n        return true;\n    }\n    bool increasing = l[1] >= l[0];\n    for (int i = 2; i < l.size(); i++) {\n        if (increasing && l[i] < l[i - 1]) {\n            return false;\n        } else if (!increasing && l[i] > l[i - 1]) {\n            return false;\n        }\n    }\n    return true;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1) {\n        return true;\n    }\n    bool increasing = l[1] >= l[0];\n    for (int i = 2; i < l.size(); i++) {\n        if (increasing && l[i] < l[i - 1]) {\n            return false;\n        } else if (!increasing && l[i] > l[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}"}
{"task_id": "HumanEval_12_longest", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n    std::string longest_string = strings[0];\n    for (const std::string& str : strings) {\n        if (str.length() > longest_string.length()) {\n            longest_string = str;\n        }\n    }\n    return longest_string;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n    std::string longest_string = strings[0];\n    for (const std::string& str : strings) {\n        if (str.length() > longest_string.length()) {\n            longest_string = str;\n        }\n    }\n    return longest_string;\n}\n\nint main() {\n    assert(longest(std::vector<std::string>()) == std::nullopt);\n    assert(longest(std::vector<std::string>({\"a\", \"b\", \"c\"})) == \"a\");\n    assert(longest(std::vector<std::string>({\"a\", \"bb\", \"ccc\"})) == \"ccc\");\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_52_below_threshold", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n\n    for (long i : l) {\n        if (i >= t) {\n            return false;\n        }\n    }\n    return true;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long i : l) {\n        if (i >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    assert(below_threshold(std::vector<long>({1, 2, 4, 10}), 100) == true);\n    assert(below_threshold(std::vector<long>({1, 20, 4, 10}), 5) == false);\n    std::cout << \"All test cases passed!\" << std::endl;\n}"}
{"task_id": "HumanEval_75_is_multiply_prime", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n\n    // Your code here.\n    if(a<2) return false;\n    int count=0;\n    for(int i=2;i<=a;i++){\n        if(a%i==0){\n            int j=2;\n            while(j*j<=i){\n                if(i%j==0) break;\n                j++;\n            }\n            if(j*j>i) count++;\n        }\n    }\n    if(count==3) return true;\n    return false;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    // Your code here.\n    if(a<2) return false;\n    int count=0;\n    for(int i=2;i<=a;i++){\n        if(a%i==0){\n            int j=2;\n            while(j*j<=i){\n                if(i%j==0) break;\n                j++;\n            }\n            if(j*j>i) count++;\n        }\n    }\n    if(count==3) return true;\n    return false;\n}\n\nint main() {\n    assert(is_multiply_prime(30) == true);\n    assert(is_multiply_prime(8) == true);\n    assert(is_multiply_prime(10) == false);\n    assert(is_multiply_prime(125) == true);\n    assert(is_multiply_prime(105) == true);\n    assert(is_multiply_prime(126) == false);\n    assert(is_multiply_prime(729) == false);\n    assert(is_multiply_prime(891) == false);\n    assert(is_multiply_prime(1001) == true);\n    assert(is_multiply_prime(91) == true);\n    assert(is_multiply_prime(4) == false);\n    assert(is_multiply_prime(1) == false);\n    assert(is_multiply_prime(15) == true);\n    assert(is_multiply_prime(21) == true);\n    assert(is_multiply_prime(2) == false);\n    assert(is_multiply_prime(3) == false);\n    assert(is_multiply_prime(45) == true);\n    assert(is_multiply_prime(9699690) == true);\n    assert(is_multiply_prime(37) == false);\n    assert(is_multiply_prime(33) == true);\n    assert(is_multiply_prime(78) == false);\n    assert(is_multiply_prime(7) == false);\n    assert(is_multiply_prime(17) == false);\n    assert(is_multiply_prime(36) == false);\n    assert(is_multiply_prime(39) == true);\n    assert(is_multiply_prime(27) == false);\n    assert(is_multiply_prime(35) == true);\n    assert(is_multiply_prime(85) == true);\n    assert(is_multiply_prime(77) == true);\n    assert(is_multiply_prime(1000000000000) == false);\n    assert(is_multiply_prime(945) == true);\n    assert(is_multiply_prime(15625"}
{"task_id": "HumanEval_30_get_positive", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert((get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6}))) == (std::vector<long>({(long)2, (long)5, (long)6}))));\n    assert((get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))));\n}"}
{"task_id": "HumanEval_33_sort_third", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n\n    std::vector<long> l2;\n    std::vector<long> l3;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l3.push_back(l[i]);\n        } else {\n            l2.push_back(l[i]);\n        }\n    }\n    std::sort(l3.begin(), l3.end());\n    std::vector<long> l4;\n    for (int i = 0; i < l2.size(); i++) {\n        l4.push_back(l2[i]);\n        l4.push_back(l3[i]);\n    }\n    l4.push_back(l3[l3.size() - 1]);\n    return l4;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l2;\n    std::vector<long> l3;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l3.push_back(l[i]);\n        } else {\n            l2.push_back(l[i]);\n        }\n    }\n    std::sort(l3.begin(), l3.end());\n    std::vector<long> l4;\n    for (int i = 0; i < l2.size(); i++) {\n        l4.push_back(l2[i]);\n        l4.push_back(l3[i]);\n    }\n    l4.push_back(l3[l3.size() - 1]);\n    return l4;\n}\n\nint main() {\n    assert((sort_third((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3}))));\n    assert((sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))));\n}"}
{"task_id": "HumanEval_6_parse_nested_parens", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string group;\n    while (std::getline(ss, group, ' ')) {\n        long max_depth = 0;\n        long current_depth = 0;\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = std::max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        result.push_back(max_depth);\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string group;\n    while (std::getline(ss, group, ' ')) {\n        long max_depth = 0;\n        long current_depth = 0;\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = std::max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        result.push_back(max_depth);\n    }\n    return result;\n}\n\nint main() {\n    assert((parse_nested_parens(\"(()()) ((())) () ((())()())\") == std::vector<long>({2, 3, 1, 3})));\n    assert((parse_nested_parens(\"(((()))) (()) ()\") == std::vector<long>({4, 2, 1})));\n    assert((parse_nested_parens(\"()\") == std::vector<long>({1})));\n    assert((parse_nested_parens(\"\") == std::vector<long>({})));\n    std::cout << \"All test cases passed!\" << std::endl;\n}"}
{"task_id": "HumanEval_45_triangle_area", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n\n    return (a*h)/2;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (a*h)/2;\n}\n\nint main() {\n    assert(triangle_area(5, 3) == 7.5f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(10, 10) == 50.0f);\n    assert(triangle_area(1"}
{"task_id": "HumanEval_97_multiply", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n\n    return (a%10)*(b%10);", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    return (a%10)*(b%10);\n}"}
{"task_id": "HumanEval_4_mean_absolute_deviation", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n\n    float sum = 0.0f;\n    for (auto number : numbers) {\n        sum += number;\n    }\n    float mean = sum / numbers.size();\n    float mad = 0.0f;\n    for (auto number : numbers) {\n        mad += std::abs(number - mean);\n    }\n    return mad / numbers.size();", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float sum = 0.0f;\n    for (auto number : numbers) {\n        sum += number;\n    }\n    float mean = sum / numbers.size();\n    float mad = 0.0f;\n    for (auto number : numbers) {\n        mad += std::abs(number - mean);\n    }\n    return mad / numbers.size();\n}\n\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the median of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (median in this case):\n// MAD = average | x - x_median |\n// >>> mean_absolute_deviation_median((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation_median(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float median = numbers[numbers.size() / 2];\n    float mad = 0.0f;\n    for (auto number : numbers) {\n        mad += std::abs(number - median);\n    }\n    return mad / numbers.size();\n}\n\n// For a given vector of input numbers, calculate Median Absolute Deviation\n// around the median of this dataset.\n// Median Absolute Deviation is the median of absolute difference between each\n// element and a centerpoint (median in this case):\n// MAD = median | x - x_median |\n// >>> median_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat median_absolute_deviation(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float median = numbers[numbers.size() / 2];\n    std::vector<float> mad;\n    for (auto number : numbers) {\n        mad.push_back(std::abs(number - median));\n    }\n    std::sort(mad.begin(), mad.end());\n    return mad[numbers.size() / 2];\n}\n\n// For a given vector of input numbers, calculate Median Absolute Deviation\n// around the mean of this dataset.\n// Median Absolute Deviation is the median of absolute difference between each\n// element"}
{"task_id": "HumanEval_58_common", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n    return result;\n}\n\nint main() {\n    assert((common(std::vector<long>({1, 4, 3, 34, 653, 2, 5}), std::vector<long>({5, 7, 1, 5, 9, 653, 121})) == std::vector<long>({1, 5, 653})));\n    assert((common(std::vector<long>({5, 3, 2, 8}), std::vector<long>({3, 2})) == std::vector<long>({2, 3})));\n    std::cout << \"All test cases passed successfully.\" << std::endl;\n}"}
{"task_id": "HumanEval_156_int_to_mini_roman", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n\n    std::string roman = \"\";\n    std::map<int, std::string> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"},\n        {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto it = roman_numerals.rbegin(); it != roman_numerals.rend(); ++it) {\n        while (number >= it->first) {\n            roman += it->second;\n            number -= it->first;\n        }\n    }\n    return roman;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string roman = \"\";\n    std::map<int, std::string> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"},\n        {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n    for (auto it = roman_numerals.rbegin(); it != roman_numerals.rend(); ++it) {\n        while (number >= it->first) {\n            roman += it->second;\n            number -= it->first;\n        }\n    }\n    return roman;\n}\n\nint main() {\n    assert(int_to_mini_roman(19) == \"xix\");\n    assert(int_to_mini_roman(152) == \"clii\");\n    assert(int_to_mini_roman(426) == \"cdxxvi\");\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_67_fruit_distribution", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n\n    std::string s1 = s.substr(0, s.find(\" \"));\n    std::string s2 = s.substr(s.find(\" \") + 1, s.find(\" \") + 10);\n    std::string s3 = s.substr(s.find(\" \") + 11, s.find(\" \") + 20);\n    std::string s4 = s.substr(s.find(\" \") + 21, s.find(\" \") + 30);\n    long a = std::stol(s1);\n    long b = std::stol(s3);\n    long c = std::stol(s4);\n    return n - a - b - c;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    std::string s1 = s.substr(0, s.find(\" \"));\n    std::string s2 = s.substr(s.find(\" \") + 1, s.find(\" \") + 10);\n    std::string s3 = s.substr(s.find(\" \") + 11, s.find(\" \") + 20);\n    std::string s4 = s.substr(s.find(\" \") + 21, s.find(\" \") + 30);\n    long a = std::stol(s1);\n    long b = std::stol(s3);\n    long c = std::stol(s4);\n    return n - a - b - c;\n}\n\nint main() {\n    assert((fruit_distribution(\"5 apples and 6 oranges\", 19) == 8));\n    assert((fruit_distribution(\"0 apples and 1 oranges\", 3) == 2));\n    assert((fruit_distribution(\"2 apples and 3 oranges\", 100) == 95));\n    assert((fruit_distribution(\"100 apples and 1 oranges\", 120) == 19));\n    std::cout << \"All test cases passed successfully.\" << std::endl;\n}"}
{"task_id": "HumanEval_112_reverse_delete", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n\n    std::string result = \"\";\n    for (int i = 0; i < s.length(); i++) {\n        if (c.find(s[i]) == std::string::npos) {\n            result += s[i];\n        }\n    }\n    std::string reversed = result;\n    std::reverse(reversed.begin(), reversed.end());\n    return std::make_tuple(result, result == reversed);", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    std::string result = \"\";\n    for (int i = 0; i < s.length(); i++) {\n        if (c.find(s[i]) == std::string::npos) {\n            result += s[i];\n        }\n    }\n    std::string reversed = result;\n    std::reverse(reversed.begin(), reversed.end());\n    return std::make_tuple(result, result == reversed);\n}\n\nint main() {\n    assert(reverse_delete(\"abcde\", \"ae\") == std::make_tuple(\"bcd\", false));\n    assert(reverse_delete(\"abcdef\", \"b\") == std::make_tuple(\"acdef\", false));\n    assert(reverse_delete(\"abcdedcba\", \"ab\") == std::make_tuple(\"cdedc\", true));\n    return 0;\n}"}
{"task_id": "HumanEval_13_greatest_common_divisor", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n\n    if (b == 0) {\n        return a;\n    }\n    return greatest_common_divisor(b, a % b);", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    if (b == 0) {\n        return a;\n    }\n    return greatest_common_divisor(b, a % b);\n}\n\n// Return a least common multiple of two integers a and b\n// >>> least_common_multiple((3), (5))\n// (15)\n// >>> least_common_multiple((25), (15))\n// (75)\nlong least_common_multiple(long a, long b) {\n    return a * b / greatest_common_divisor(a, b);\n}\n\n// Return a greatest common divisor of a list of integers\n// >>> greatest_common_divisor_list((3, 5))\n// (1)\n// >>> greatest_common_divisor_list((25, 15, 10))\n// (5)\nlong greatest_common_divisor_list(std::vector<long> &numbers) {\n    long result = numbers[0];\n    for (int i = 1; i < numbers.size(); i++) {\n        result = greatest_common_divisor(result, numbers[i]);\n    }\n    return result;\n}\n\n// Return a least common multiple of a list of integers\n// >>> least_common_multiple_list((3, 5))\n// (15)\n// >>> least_common_multiple_list((25, 15, 10))\n// (75)\nlong least_common_multiple_list(std::vector<long> &numbers) {\n    long result = numbers[0];\n    for (int i = 1; i < numbers.size(); i++) {\n        result = least_common_multiple(result, numbers[i]);\n    }\n    return result;\n}\n\n// Return a greatest common divisor of a list of integers\n// >>> greatest_common_divisor_list((3, 5))\n// (1)\n// >>> greatest_common_divisor_list((25, 15, 10))\n// (5)\nlong greatest_common_divisor_list(std::vector<long> &&numbers) {\n    long result = numbers[0];\n    for (int i = 1; i < numbers.size(); i++) {\n        result = greatest_common_divisor(result, numbers[i]);\n    }\n    return result;\n}\n\n// Return a least common multiple of a list of integers\n// >>> least_common_multiple_list((3, 5))\n// (15)\n// >>> least_common_multiple_list((25, 15, 10))\n// (75)\nlong least_common_multiple_list(std::vector<long> &&numbers) {\n    long"}
{"task_id": "HumanEval_125_split_words", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n\n    if (txt.find(' ') != std::string::npos) {\n        std::vector<std::string> words;\n        std::stringstream ss(txt);\n        std::string word;\n        while (ss >> word) {\n            words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n    } else if (txt.find(',') != std::string::npos) {\n        std::vector<std::string> words;\n        std::stringstream ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ',')) {\n            words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n    } else {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z' && (c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    if (txt.find(' ') != std::string::npos) {\n        std::vector<std::string> words;\n        std::stringstream ss(txt);\n        std::string word;\n        while (ss >> word) {\n            words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n    } else if (txt.find(',') != std::string::npos) {\n        std::vector<std::string> words;\n        std::stringstream ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ',')) {\n            words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n    } else {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z' && (c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n}\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    if (txt.find(' ') != std::string::npos) {\n        std::vector<std::string> words;\n        std::stringstream ss(txt);\n        std::string word;\n        while (ss >> word) {\n            words.push_back(word);\n        }\n        return Union_std_vector_std_string__long(words);\n    } else if (txt.find(',') != std::string::npos) {\n        std::vector<std::string> words;\n        std::stringstream ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ',')) {\n            words.push"}
{"task_id": "HumanEval_116_sort_array", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n\n    std::vector<long> result;\n    std::vector<long> temp;\n    std::vector<long> temp2;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] >= 0) {\n            temp.push_back(arr[i]);\n        } else {\n            temp2.push_back(arr[i]);\n        }\n    }\n    std::sort(temp.begin(), temp.end(), [](long a, long b) {\n        int count1 = 0;\n        int count2 = 0;\n        long temp1 = a;\n        long temp2 = b;\n        while (temp1 > 0) {\n            count1 += temp1 % 2;\n            temp1 /= 2;\n        }\n        while (temp2 > 0) {\n            count2 += temp2 % 2;\n            temp2 /= 2;\n        }\n        if (count1 == count2) {\n            return a < b;\n        }\n        return count1 < count2;\n    });\n    for (int i = 0; i < temp2.size(); i++) {\n        result.push_back(temp2[i]);\n    }\n    for (int i = 0; i < temp.size(); i++) {\n        result.push_back(temp[i]);\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::vector<long> result;\n    std::vector<long> temp;\n    std::vector<long> temp2;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] >= 0) {\n            temp.push_back(arr[i]);\n        } else {\n            temp2.push_back(arr[i]);\n        }\n    }\n    std::sort(temp.begin(), temp.end(), [](long a, long b) {\n        int count1 = 0;\n        int count2 = 0;\n        long temp1 = a;\n        long temp2 = b;\n        while (temp1 > 0) {\n            count1 += temp1 % 2;\n            temp1 /= 2;\n        }\n        while (temp2 > 0) {\n            count2 += temp2 % 2;\n            temp2 /= 2;\n        }\n        if (count1 == count2) {\n            return a < b;\n        }\n        return count1 < count2;\n    });\n    for (int i = 0; i < temp2.size(); i++) {\n        result.push_back(temp2[i]);\n    }\n    for (int i = 0; i < temp.size(); i++) {\n        result.push_back(temp[i]);\n    }\n    return result;\n}\n\nint main() {\n    assert((sort_array(std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})) == std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})));\n    assert((sort_array(std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})) == std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2})));\n    assert((sort_array(std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})) == std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4})));\n    return 0;\n}"}
{"task_id": "HumanEval_28_concatenate", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n\n    std::string result;\n    for (std::string string : strings) {\n        result += string;\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n    std::string result;\n    for (std::string string : strings) {\n        result += string;\n    }\n    return result;\n}\n\n// Concatenate vector of strings into a single string with a given separator\n// >>> concatenate((std::vector<std::string>()), (std::string)(\", \"))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})), (std::string)(\", \"))\n// (\"a, b, c\")\nstd::string concatenate(std::vector<std::string> strings, std::string separator) {\n    std::string result;\n    for (int i = 0; i < strings.size(); i++) {\n        result += strings[i];\n        if (i != strings.size() - 1) {\n            result += separator;\n        }\n    }\n    return result;\n}\n\n// Concatenate vector of strings into a single string with a given separator and ending\n// >>> concatenate((std::vector<std::string>()), (std::string)(\", \"), (std::string)(\";\"))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})), (std::string)(\", \"), (std::string)(\";\"))\n// (\"a, b, c;\")\nstd::string concatenate(std::vector<std::string> strings, std::string separator, std::string ending) {\n    std::string result;\n    for (int i = 0; i < strings.size(); i++) {\n        result += strings[i];\n        if (i != strings.size() - 1) {\n            result += separator;\n        } else {\n            result += ending;\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert(concatenate((std::vector<std::string>())) == (\"\"));\n    assert(concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"}))) == (\"abc\"));\n    assert(concatenate((std::vector<std::string>()), (std::string)(\", \")) == (\"\"));\n    assert(concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})), (std::string)(\","}
{"task_id": "HumanEval_149_sorted_list_sum", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n\n    std::vector<std::string> result;\n    for (auto it = lst.begin(); it != lst.end(); it++) {\n        if (it->length() % 2 == 0) {\n            result.push_back(*it);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto it = lst.begin(); it != lst.end(); it++) {\n        if (it->length() % 2 == 0) {\n            result.push_back(*it);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;\n}\n\nint main() {\n    assert(sorted_list_sum(std::vector<std::string>({std::string(\"aa\"), std::string(\"a\"), std::string(\"aaa\")})) == std::vector<std::string>({std::string(\"aa\")}));\n    assert(sorted_list_sum(std::vector<std::string>({std::string(\"ab\"), std::string(\"a\"), std::string(\"aaa\"), std::string(\"cd\")})) == std::vector<std::string>({std::string(\"ab\"), std::string(\"cd\")}));\n    return 0;\n}"}
{"task_id": "HumanEval_7_filter_by_substring", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n\n    std::vector<std::string> result;\n    for (auto s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> result;\n    for (auto s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> result;\n    for (auto s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert((filter_by_substring(std::vector<std::string>(), \"a\") == std::vector<std::string>()));\n    assert((filter_by_substring(std::vector<std::string>{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\") == std::vector<std::string>{\"abc\", \"bacd\", \"array\"}));\n    std::cout << \"All test cases passed successfully!\" << std::endl;\n}"}
{"task_id": "HumanEval_99_closest_integer", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n\n  long result = std::stol(value);\n  if (value.find('.') != std::string::npos) {\n    long decimal = std::stol(value.substr(value.find('.') + 1));\n    if (decimal >= 5) {\n      result += (result > 0) ? 1 : -1;\n    }\n  }\n  return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  long result = std::stol(value);\n  if (value.find('.') != std::string::npos) {\n    long decimal = std::stol(value.substr(value.find('.') + 1));\n    if (decimal >= 5) {\n      result += (result > 0) ? 1 : -1;\n    }\n  }\n  return result;\n}\n\nint main() {\n  assert(closest_integer(\"10\") == 10);\n  assert(closest_integer(\"15.3\") == 15);\n  assert(closest_integer(\"14.5\") == 15);\n  assert(closest_integer(\"-14.5\") == -15);\n  assert(closest_integer(\"14.51\") == 15);\n  assert(closest_integer(\"-14.51\") == -15);\n  assert(closest_integer(\"14.49\") == 14);\n  assert(closest_integer(\"-14.49\") == -14);\n  assert(closest_integer(\"14.50\") == 15);\n  assert(closest_integer(\"-14.50\") == -15);\n  assert(closest_integer(\"14.500\") == 15);\n  assert(closest_integer(\"-14.500\") == -15);\n  assert(closest_integer(\"14.5000\") == 15);\n  assert(closest_integer(\"-14.5000\") == -15);\n  assert(closest_integer(\"14.50000\") == 15);\n  assert(closest_integer(\"-14.50000\") == -15);\n  assert(closest_integer(\"14.500000\") == 15);\n  assert(closest_integer(\"-14.500000\") == -15);\n  assert(closest_integer(\"14.5000000\") == 15);\n  assert(closest_integer(\"-14.5000000\") == -15);\n  assert(closest_integer(\"14.50000000\") == 15);\n  assert(closest_integer(\"-14.50000000\") == -15);\n  assert(closest_integer(\"14."}
{"task_id": "HumanEval_64_vowels_count", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n\n    long count = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    if (s[s.length() - 1] == 'y' || s[s.length() - 1] == 'Y') {\n        count++;\n    }\n    return count;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    if (s[s.length() - 1] == 'y' || s[s.length() - 1] == 'Y') {\n        count++;\n    }\n    return count;\n}\n\n// Write a function is_palindrome which takes a string representing\n// a word as input and returns true if the word is a palindrome and\n// false otherwise. A palindrome is a word which is the same when\n// read backwards.\n// Example:\n// >>> is_palindrome((\"abcba\"))\n// (true)\n// >>> is_palindrome((\"ACEDY\"))\n// (false)\nbool is_palindrome(std::string s) {\n    for (int i = 0; i < s.length() / 2; i++) {\n        if (s[i] != s[s.length() - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Write a function is_anagram which takes two strings representing\n// words as input and returns true if the words are anagrams and\n// false otherwise. An anagram is a word which is made by rearranging\n// the letters of another word.\n// Example:\n// >>> is_anagram((\"abcde\"), (\"edcba\"))\n// (true)\n// >>> is_anagram((\"ACEDY\"), (\"ACEDY\"))\n// (false)\nbool is_anagram(std::string s1, std::string s2) {\n    if (s1.length() != s2.length()) {\n        return false;\n    }\n    std::sort(s1.begin(), s1.end());\n    std::sort(s2.begin(), s2.end());\n    return s1 == s2;\n}\n\n// Write a function is_palindrome_phrase which takes a string\n// representing a phrase as input and returns true if the phrase is\n// a palindrome and false otherwise. A palindrome is a phrase which\n// is the"}
{"task_id": "HumanEval_158_find_max", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n\n    std::string max_word = \"\";\n    int max_unique_chars = 0;\n    for (const auto& word : words) {\n        std::unordered_set<char> unique_chars(word.begin(), word.end());\n        if (unique_chars.size() > max_unique_chars) {\n            max_unique_chars = unique_chars.size();\n            max_word = word;\n        } else if (unique_chars.size() == max_unique_chars && word < max_word) {\n            max_word = word;\n        }\n    }\n    return max_word;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n    std::string max_word = \"\";\n    int max_unique_chars = 0;\n    for (const auto& word : words) {\n        std::unordered_set<char> unique_chars(word.begin(), word.end());\n        if (unique_chars.size() > max_unique_chars) {\n            max_unique_chars = unique_chars.size();\n            max_word = word;\n        } else if (unique_chars.size() == max_unique_chars && word < max_word) {\n            max_word = word;\n        }\n    }\n    return max_word;\n}\n\nint main() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n    assert(find_max({\"abc\", \"def\", \"ghi\"}) == \"abc\");\n    assert(find_max({\"abc\", \"def\", \"ghi\", \"jkl\"}) == \"abc\");\n    assert(find_max({\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"}) == \"abc\");\n    assert(find_max({\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\"}) == \"abc\");\n    assert(find_max({\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\"}) == \"abc\");\n    assert(find_max({\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\"}) == \"abc\");\n    assert(find_max({\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yz\"}) == \"abc\");\n    assert(find_max({\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yz\", \"123\"}) == \"abc\");\n    assert(find_max({\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yz\", \"123\", \"456\"}) == \"abc\");\n    assert(find_max({\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yz\", \"123\", \"4"}
{"task_id": "HumanEval_162_string_to_md5", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n\n    if (text.empty()) {\n        return std::nullopt;\n    }\n    std::string md5_hash = \"\";\n    std::hash<std::string> hash_fn;\n    size_t hash_value = hash_fn(text);\n    md5_hash = std::to_string(hash_value);\n    return md5_hash;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n    std::string md5_hash = \"\";\n    std::hash<std::string> hash_fn;\n    size_t hash_value = hash_fn(text);\n    md5_hash = std::to_string(hash_value);\n    return md5_hash;\n}\n\n// Given a string 'text', return its sha256 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_sha256((\"Hello world\"))\n// \"a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e\"\nstd::optional<std::string> string_to_sha256(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n    std::string sha256_hash = \"\";\n    std::hash<std::string> hash_fn;\n    size_t hash_value = hash_fn(text);\n    sha256_hash = std::to_string(hash_value);\n    return sha256_hash;\n}\n\n// Given a string 'text', return its sha384 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_sha384((\"Hello world\"))\n// \"3d8a0f2e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}
{"task_id": "HumanEval_44_change_base", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n\n    std::string result = \"\";\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string result = \"\";\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string result = \"\";\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}"}
{"task_id": "HumanEval_157_right_angle_triangle", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n\n    long max = std::max(a, std::max(b, c));\n    long min = std::min(a, std::min(b, c));\n    long mid = a + b + c - max - min;\n    return max * max == min * min + mid * mid;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    long max = std::max(a, std::max(b, c));\n    long min = std::min(a, std::min(b, c));\n    long mid = a + b + c - max - min;\n    return max * max == min * min + mid * mid;\n}\n\nint main() {\n    assert(right_angle_triangle(3, 4, 5) == true);\n    assert(right_angle_triangle(1, 2, 3) == false);\n    assert(right_angle_triangle(5, 12, 13) == true);\n    assert(right_angle_triangle(10, 6, 8) == true);\n    assert(right_angle_triangle(7, 24, 25) == true);\n    assert(right_angle_triangle(2, 2, 2) == false);\n    assert(right_angle_triangle(10, 10, 10) == false);\n    assert(right_angle_triangle(1, 1, 1) == false);\n    assert(right_angle_triangle(0, 0, 0) == false);\n    assert(right_angle_triangle(-1, -1, -1) == false);\n    assert(right_angle_triangle(1.5, 2.5, 3.5) == false);\n    assert(right_angle_triangle(1.5, 2.5, 3.5) == false);\n    assert(right_angle_triangle(1.5, 2.5, 3.5) == false);\n    assert(right_angle_triangle(1.5, 2.5, 3.5) == false);\n    assert(right_angle_triangle(1.5, 2.5, 3.5) == false);\n    assert(right_angle_triangle(1.5, 2.5, 3.5) == false);\n    assert(right_angle_triangle(1.5, 2.5, 3.5) == false);\n    assert(right_angle_triangle(1.5, 2.5, 3.5) == false);\n    assert(right_angle_triangle(1.5, 2.5, 3.5) == false);\n    assert(right_angle_triangle(1.5, 2.5, 3.5) == false);\n    assert(right_angle_triangle(1.5, 2.5, 3.5) == false);\n    assert(right_angle"}
{"task_id": "HumanEval_81_numerical_letter_grade", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n\n    std::vector<std::string> letter_grades;\n    for (float grade : grades) {\n        if (grade == 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade > 3.7f) {\n            letter_grades.push_back(\"A\");\n        } else if (grade > 3.3f) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade > 3.0f) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade > 2.7f) {\n            letter_grades.push_back(\"B\");\n        } else if (grade > 2.3f) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade > 2.0f) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade > 1.7f) {\n            letter_grades.push_back(\"C\");\n        } else if (grade > 1.3f) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade > 1.0f) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade > 0.7f) {\n            letter_grades.push_back(\"D\");\n        } else if (grade > 0.0f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for (float grade : grades) {\n        if (grade == 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade > 3.7f) {\n            letter_grades.push_back(\"A\");\n        } else if (grade > 3.3f) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade > 3.0f) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade > 2.7f) {\n            letter_grades.push_back(\"B\");\n        } else if (grade > 2.3f) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade > 2.0f) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade > 1.7f) {\n            letter_grades.push_back(\"C\");\n        } else if (grade > 1.3f) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade > 1.0f) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade > 0.7f) {\n            letter_grades.push_back(\"D\");\n        } else if (grade > 0.0f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n\nint main() {\n    assert((numerical_letter_grade(std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})) == std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"})));\n    std::cout<<\"test cases passed successfully.\\n\";\n}"}
{"task_id": "HumanEval_5_intersperse", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n\n    std::vector<long> result;\n    for (int i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (int i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert((intersperse(std::vector<long>(), 4) == std::vector<long>()));\n    assert((intersperse(std::vector<long>({1, 2, 3}), 4) == std::vector<long>({1, 4, 2, 4, 3})));\n}"}
{"task_id": "HumanEval_146_specialFilter", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10 && num % 10 % 2 == 1 && num / 10 % 2 == 1) {\n            count++;\n        }\n    }\n    return count;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10 && num % 10 % 2 == 1 && num / 10 % 2 == 1) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    assert(specialFilter(std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})) == 1);\n    assert(specialFilter(std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})) == 2);\n    assert(specialFilter(std::vector<long>({(long)11, (long)22, (long)33, (long)44, (long)55})) == 3);\n    assert(specialFilter(std::vector<long>({(long)10, (long)20, (long)30, (long)40, (long)50})) == 0);\n    assert(specialFilter(std::vector<long>({(long)1, (long)3, (long)5, (long)7, (long)9})) == 0);\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_60_sum_to_n", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n\n    return n*(n+1)/2;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return n*(n+1)/2;\n}\n\nint main() {\n    assert(sum_to_n(30) == 465);\n    assert(sum_to_n(100) == 5050);\n    assert(sum_to_n(5) == 15);\n    assert(sum_to_n(10) == 55);\n    assert(sum_to_n(1) == 1);\n    std::cout << \"All test cases passed!\" << std::endl;\n}"}
{"task_id": "HumanEval_26_remove_duplicates", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n\n    std::vector<long> result;\n    std::unordered_map<long, int> m;\n    for (auto i : numbers) {\n        m[i]++;\n    }\n    for (auto i : numbers) {\n        if (m[i] == 1) {\n            result.push_back(i);\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    std::unordered_map<long, int> m;\n    for (auto i : numbers) {\n        m[i]++;\n    }\n    for (auto i : numbers) {\n        if (m[i] == 1) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert((remove_duplicates(std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})) == std::vector<long>({(long)1, (long)3, (long)4})));\n    assert((remove_duplicates(std::vector<long>({(long)1, (long)1, (long)2, (long)2, (long)3, (long)3, (long)4, (long)4})) == std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert((remove_duplicates(std::vector<long>({(long)1, (long)2, (long)3, (long)4})) == std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert((remove_duplicates(std::vector<long>({(long)1, (long)1, (long)1, (long)1})) == std::vector<long>({(long)1})));\n    std::cout << \"All test cases passed successfully!\" << std::endl;\n}"}
{"task_id": "HumanEval_163_generate_integers", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n\n    std::vector<long> result;\n    if (a > b) {\n        std::swap(a, b);\n    }\n    for (long i = a; i <= b; i++) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n    std::vector<long> result;\n    if (a > b) {\n        std::swap(a, b);\n    }\n    for (long i = a; i <= b; i++) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\n\nint main() {\n    assert((generate_integers(2, 8) == std::vector<long>({2, 4, 6, 8})));\n    assert((generate_integers(8, 2) == std::vector<long>({2, 4, 6, 8})));\n    assert((generate_integers(10, 14) == std::vector<long>()));\n    std::cout << \"All cases passed\" << std::endl;\n    return 0;\n}"}
{"task_id": "HumanEval_9_rolling_max", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n\n    std::vector<long> result;\n    long max = numbers[0];\n    for (long i = 0; i < numbers.size(); i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n        result.push_back(max);\n    }\n    return result;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max = numbers[0];\n    for (long i = 0; i < numbers.size(); i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n        result.push_back(max);\n    }\n    return result;\n}\n\nint main() {\n    assert((rolling_max(std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})) == std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4})));\n    assert((rolling_max(std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})) == std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4})));\n    assert((rolling_max(std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})) == std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4})));\n    assert((rolling_max(std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})) == std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4})));\n    assert((rolling_max(std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})) == std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)"}
{"task_id": "HumanEval_3_below_zero", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n\n    long balance = 0;\n    for (auto op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (auto op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    assert(below_zero(std::vector<long>({(long)1, (long)2, (long)3})) == false);\n    assert(below_zero(std::vector<long>({(long)1, (long)2, (long)-4, (long)5})) == true);\n    std::cout << \"Pass test cases\" << std::endl;\n}"}
{"task_id": "HumanEval_69_search", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n\n    std::map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n    long max = -1;\n    for (auto it = freq.begin(); it != freq.end(); it++) {\n        if (it->first <= it->second && it->first > max) {\n            max = it->first;\n        }\n    }\n    return max;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n    long max = -1;\n    for (auto it = freq.begin(); it != freq.end(); it++) {\n        if (it->first <= it->second && it->first > max) {\n            max = it->first;\n        }\n    }\n    return max;\n}\n\nint main() {\n    assert(search(std::vector<long>({4, 1, 2, 2, 3, 1})) == 2);\n    assert(search(std::vector<long>({1, 2, 2, 3, 3, 3, 4, 4, 4})) == 3);\n    assert(search(std::vector<long>({5, 5, 4, 4, 4})) == -1);\n    std::cout << \"All test cases passed successfully.\" << std::endl;\n}"}
{"task_id": "HumanEval_61_correct_bracketing", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            count++;\n        } else if (c == ')') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            count++;\n        } else if (c == ')') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}"}
{"task_id": "HumanEval_37_sort_even", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n\n    std::vector<long> l_even;\n    for (int i = 0; i < l.size(); i += 2) {\n        l_even.push_back(l[i]);\n    }\n    std::sort(l_even.begin(), l_even.end());\n    for (int i = 0; i < l_even.size(); i++) {\n        l[2 * i] = l_even[i];\n    }\n    return l;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> l_even;\n    for (int i = 0; i < l.size(); i += 2) {\n        l_even.push_back(l[i]);\n    }\n    std::sort(l_even.begin(), l_even.end());\n    for (int i = 0; i < l_even.size(); i++) {\n        l[2 * i] = l_even[i];\n    }\n    return l;\n}\n\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the even indicies, while its values at the odd indicies are equal\n// to the values of the odd indicies of l, but sorted.\n// >>> sort_odd((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_odd((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)5, (long)4, (long)3, (long)6}))\nstd::vector<long> sort_odd(std::vector<long> l) {\n    std::vector<long> l_odd;\n    for (int i = 1; i < l.size(); i += 2) {\n        l_odd.push_back(l[i]);\n    }\n    std::sort(l_odd.begin(), l_odd.end());\n    for (int i = 0; i < l_odd.size(); i++) {\n        l[2 * i + 1] = l_odd[i];\n    }\n    return l;\n}\n\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long"}
{"task_id": "HumanEval_54_same_chars", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;\n}\n\nint main() {\n    assert(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(same_chars(\"abcd\", \"dddddddabc\") == true);\n    assert(same_chars(\"dddddddabc\", \"abcd\") == true);\n    assert(same_chars(\"eabcd\", \"dddddddabc\") == false);\n    assert(same_chars(\"abcd\", \"dddddddabce\") == false);\n    assert(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n}"}
{"task_id": "HumanEval_56_correct_bracketing", "generation": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n", "wholecode": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}"}
